{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"About Me Introduction Hello there! My name is Aditya, and I am a passionate DevOps enthusiast. I have dedicated my career to mastering the art of automating software delivery processes, ensuring seamless collaboration between development and operations teams. Background I have been working in the field of DevOps for some years, during which I have gained extensive experience in various aspects of the discipline. My expertise spans across multiple domains, including continuous integration and continuous deployment (CI/CD), infrastructure as code (IaC), containerization, and cloud computing. Skills Automation Tools: Proficient in utilizing tools like Ansible, Terraform, and Puppet for infrastructure provisioning and configuration management. Containerization: Experienced in working with Docker and Kubernetes for containerizing applications and managing container orchestration. CI/CD Pipelines: Skilled in setting up and maintaining CI/CD pipelines using tools like Jenkins, GitLab CI/CD, and GitHub Actions. Monitoring and Logging: Adept at implementing monitoring and logging solutions such as Prometheus, Grafana, and ELK Stack (Elasticsearch, Logstash, Kibana). Cloud Platforms: Familiar with cloud providers like AWS, Azure, and GCP, and their respective services for deploying and managing applications. Passion and Motivation I firmly believe that DevOps is more than just a set of tools and practices; it's a cultural shift that emphasizes collaboration, automation, and continuous improvement. My passion lies in bridging the gap between development and operations teams, fostering a harmonious and efficient software delivery process. Through this project, I aim to showcase my DevOps skills and demonstrate my ability to tackle real-world challenges. I am excited to embark on this journey and contribute to the ever-evolving world of DevOps.","title":"About Us"},{"location":"index.html#about-me","text":"","title":"About Me"},{"location":"index.html#introduction","text":"Hello there! My name is Aditya, and I am a passionate DevOps enthusiast. I have dedicated my career to mastering the art of automating software delivery processes, ensuring seamless collaboration between development and operations teams.","title":"Introduction"},{"location":"index.html#background","text":"I have been working in the field of DevOps for some years, during which I have gained extensive experience in various aspects of the discipline. My expertise spans across multiple domains, including continuous integration and continuous deployment (CI/CD), infrastructure as code (IaC), containerization, and cloud computing.","title":"Background"},{"location":"index.html#skills","text":"Automation Tools: Proficient in utilizing tools like Ansible, Terraform, and Puppet for infrastructure provisioning and configuration management. Containerization: Experienced in working with Docker and Kubernetes for containerizing applications and managing container orchestration. CI/CD Pipelines: Skilled in setting up and maintaining CI/CD pipelines using tools like Jenkins, GitLab CI/CD, and GitHub Actions. Monitoring and Logging: Adept at implementing monitoring and logging solutions such as Prometheus, Grafana, and ELK Stack (Elasticsearch, Logstash, Kibana). Cloud Platforms: Familiar with cloud providers like AWS, Azure, and GCP, and their respective services for deploying and managing applications.","title":"Skills"},{"location":"index.html#passion-and-motivation","text":"I firmly believe that DevOps is more than just a set of tools and practices; it's a cultural shift that emphasizes collaboration, automation, and continuous improvement. My passion lies in bridging the gap between development and operations teams, fostering a harmonious and efficient software delivery process. Through this project, I aim to showcase my DevOps skills and demonstrate my ability to tackle real-world challenges. I am excited to embark on this journey and contribute to the ever-evolving world of DevOps.","title":"Passion and Motivation"},{"location":"bash/conditional-expression.html","text":"In Bash, -z , -f , and -d are conditional expressions used in if statements and test commands to evaluate certain conditions. Here's a brief explanation of each: -z : Tests if a string is empty (has zero length). Example: if [ -z \"$variable\" ]; then echo \"Variable is empty\"; fi -f : Tests if a file exists and is a regular file. Example: if [ -f \"file.txt\" ]; then echo \"file.txt exists\"; fi -d : Tests if a directory exists. Example: if [ -d \"directory\" ]; then echo \"directory exists\"; fi These are just a few examples of the many conditional expressions available in Bash. Here's a list of some commonly used conditional expressions: -e : Tests if a file exists (regardless of its type). -s : Tests if a file exists and has a size greater than zero. -r , -w , -x : Tests if a file has read, write, or execute permissions, respectively. -eq , -ne , -lt , -le , -gt , -ge : Arithmetic comparisons for integers. = , != , < , > : String comparisons. && , || : Logical AND and OR operators. For the official documentation and a complete list of conditional expressions, you can refer to the following links: Bash Manual - Conditional Constructs: https://www.gnu.org/software/bash/manual/html_node/Conditional-Constructs.html Bash Reference Manual - Bash Conditional Expressions: https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html These resources provide detailed information about the various conditional expressions, their usage, and additional examples.","title":"Conditional expression"},{"location":"bash/jq.html","text":"jq (JSON): jq is a powerful command-line JSON processor. It's widely used for parsing, filtering, and transforming JSON data. Example using jq (JSON): # Extract the \"name\" field from a JSON file jq '.name' data.json","title":"Jq"},{"location":"bash/special-variable.html","text":"In shell scripting, there are several special variables (also known as shell parameters) that have specific meanings and behaviors. These special variables are often used in scripts to handle arguments, statuses, and other context-specific information. Here is a list of some commonly used special variables: Special Shell Variables $# Represents the number of positional parameters (arguments) passed to the script or function. Example: If a script is called with three arguments ( ./script.sh arg1 arg2 arg3 ), $# will be 3 . $0 Contains the name of the script or the command being executed. Example: If a script is called as ./script.sh , $0 will be ./script.sh . $1, $2, ... $N Represent the positional parameters (arguments) passed to the script or function. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $1 will be arg1 and $2 will be arg2 . $* Represents all the positional parameters as a single word. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $* will be arg1 arg2 . $@ Represents all the positional parameters as separate words. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $@ will be arg1 arg2 . $? Contains the exit status of the last command executed. Example: After a command ls is executed, $? will contain the exit status of ls . $$ Contains the process ID (PID) of the shell executing the script. Example: If a script is running, $$ will provide the PID of the shell. $! Contains the process ID of the last background command executed. Example: If a command is run in the background ( sleep 100 & ), $! will contain the PID of the sleep command. $- Contains the current options set for the shell. Example: If the shell has options like -x (for debugging), $- will include x . $_ Contains the last argument of the previous command. Example: If a command echo foo is executed, $_ will contain foo . Usage Examples Here's a small script to demonstrate some of these variables: #!/bin/bash echo \"Script name: $0\" echo \"Number of arguments: $#\" echo \"All arguments as a single word: $*\" echo \"All arguments as separate words: $@\" echo \"First argument: $1\" echo \"Second argument: $2\" echo \"Exit status of the last command: $?\" echo \"Process ID of the shell: $$\" echo \"Process ID of the last background command: $!\" # Run a background command sleep 10 & echo \"Process ID of the sleep command: $!\" echo \"Last argument of the previous command: $_\" If you run this script with some arguments, for example: ./script.sh arg1 arg2 You would see output corresponding to the special variables based on the provided arguments and the script\u2019s execution context.","title":"Special variable"},{"location":"bash/special-variable.html#special-shell-variables","text":"$# Represents the number of positional parameters (arguments) passed to the script or function. Example: If a script is called with three arguments ( ./script.sh arg1 arg2 arg3 ), $# will be 3 . $0 Contains the name of the script or the command being executed. Example: If a script is called as ./script.sh , $0 will be ./script.sh . $1, $2, ... $N Represent the positional parameters (arguments) passed to the script or function. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $1 will be arg1 and $2 will be arg2 . $* Represents all the positional parameters as a single word. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $* will be arg1 arg2 . $@ Represents all the positional parameters as separate words. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $@ will be arg1 arg2 . $? Contains the exit status of the last command executed. Example: After a command ls is executed, $? will contain the exit status of ls . $$ Contains the process ID (PID) of the shell executing the script. Example: If a script is running, $$ will provide the PID of the shell. $! Contains the process ID of the last background command executed. Example: If a command is run in the background ( sleep 100 & ), $! will contain the PID of the sleep command. $- Contains the current options set for the shell. Example: If the shell has options like -x (for debugging), $- will include x . $_ Contains the last argument of the previous command. Example: If a command echo foo is executed, $_ will contain foo .","title":"Special Shell Variables"},{"location":"bash/special-variable.html#usage-examples","text":"Here's a small script to demonstrate some of these variables: #!/bin/bash echo \"Script name: $0\" echo \"Number of arguments: $#\" echo \"All arguments as a single word: $*\" echo \"All arguments as separate words: $@\" echo \"First argument: $1\" echo \"Second argument: $2\" echo \"Exit status of the last command: $?\" echo \"Process ID of the shell: $$\" echo \"Process ID of the last background command: $!\" # Run a background command sleep 10 & echo \"Process ID of the sleep command: $!\" echo \"Last argument of the previous command: $_\" If you run this script with some arguments, for example: ./script.sh arg1 arg2 You would see output corresponding to the special variables based on the provided arguments and the script\u2019s execution context.","title":"Usage Examples"},{"location":"bash/yq.html","text":"yq (YAML): yq is a similar tool for YAML. It provides similar functionality to jq for processing YAML data. Example using yq (YAML): # Extract the \"host\" field from a YAML file yq '.host' data.yaml","title":"Yq"},{"location":"bash/projects/1-color-print-message.html","text":"https://www.squash.io/adding-color-to-bash-scripts-in-linux/ https://manned.org/tput.1 # Set color variables RED=$(tput setaf 1) GREEN=$(tput setaf 2) YELLOW=$(tput setaf 3) RESET=$(tput sgr0) tput setaf 2 echo \"hello\" #!/bin/bash color() { if [ $1 == \"red\" ]; then tput setaf 1 elif [ $1 == \"green\" ]; then tput setaf 2 elif [ $1 == \"yellow\" ]; then tput setaf 3 else tput sgr0 fi } color green echo \"hello\"","title":"https://www.squash.io/adding-color-to-bash-scripts-in-linux/"},{"location":"bash/projects/1-color-print-message.html#httpswwwsquashioadding-color-to-bash-scripts-in-linux","text":"","title":"https://www.squash.io/adding-color-to-bash-scripts-in-linux/"},{"location":"bash/projects/1-color-print-message.html#httpsmannedorgtput1","text":"","title":"https://manned.org/tput.1"},{"location":"bash/projects/1-color-print-message.html#set-color-variables","text":"","title":"# Set color variables"},{"location":"bash/projects/1-color-print-message.html#redtput-setaf-1","text":"","title":"RED=$(tput setaf 1)"},{"location":"bash/projects/1-color-print-message.html#greentput-setaf-2","text":"","title":"GREEN=$(tput setaf 2)"},{"location":"bash/projects/1-color-print-message.html#yellowtput-setaf-3","text":"","title":"YELLOW=$(tput setaf 3)"},{"location":"bash/projects/1-color-print-message.html#resettput-sgr0","text":"","title":"RESET=$(tput sgr0)"},{"location":"bash/projects/1-color-print-message.html#tput-setaf-2","text":"","title":"tput setaf 2"},{"location":"bash/projects/1-color-print-message.html#echo-hello","text":"#!/bin/bash color() { if [ $1 == \"red\" ]; then tput setaf 1 elif [ $1 == \"green\" ]; then tput setaf 2 elif [ $1 == \"yellow\" ]; then tput setaf 3 else tput sgr0 fi } color green echo \"hello\"","title":"echo \"hello\""},{"location":"docker/docker.html","text":"docker","title":"Dockercompose"},{"location":"docker/docker.html#docker","text":"","title":"docker"},{"location":"golang/complex-struct.html","text":"Sure, let's explore a more complex struct example in Go. We'll create a struct called Person that has nested structs and slices. package main import \"fmt\" // Defining a struct for Address type Address struct { Street string City string State string } // Defining a struct for Job type Job struct { Company string Title string StartYear int } // Defining the Person struct type Person struct { Name string Age int HomeAddress Address WorkAddress Address Jobs []Job } func main() { // Creating instances of Address struct homeAddress := Address{ Street: \"123 Main St\", City: \"Anytown\", State: \"CA\", } workAddress := Address{ Street: \"456 Office Rd\", City: \"Metropolis\", State: \"NY\", } // Creating instances of Job struct job1 := Job{ Company: \"Acme Inc.\", Title: \"Software Engineer\", StartYear: 2015, } job2 := Job{ Company: \"Globex Corp.\", Title: \"Senior Developer\", StartYear: 2020, } // Creating an instance of Person struct person := Person{ Name: \"John Doe\", Age: 35, HomeAddress: homeAddress, WorkAddress: workAddress, Jobs: []Job{job1, job2}, } // Accessing struct fields fmt.Println(\"Name:\", person.Name) fmt.Println(\"Age:\", person.Age) fmt.Println(\"Home Address:\", person.HomeAddress) fmt.Println(\"Work Address:\", person.WorkAddress) fmt.Println(\"Jobs:\") for _, job := range person.Jobs { fmt.Printf(\" Company: %s, Title: %s, Start Year: %d\\n\", job.Company, job.Title, job.StartYear) } } In this example, we have: An Address struct with Street , City , and State fields. A Job struct with Company , Title , and StartYear fields. A Person struct with Name , Age , HomeAddress , WorkAddress , and Jobs fields. The HomeAddress and WorkAddress fields are of type Address , and the Jobs field is a slice of Job structs. In the main function: We create instances of Address for home and work addresses. We create instances of Job for two different jobs. We create an instance of Person with the above addresses and jobs. We access and print the fields of the Person struct using dot notation. We iterate over the Jobs slice and print the details of each job. When you run this code, you'll see the following output: Name: John Doe Age: 35 Home Address: {123 Main St Anytown CA} Work Address: {456 Office Rd Metropolis NY} Jobs: Company: Acme Inc., Title: Software Engineer, Start Year: 2015 Company: Globex Corp., Title: Senior Developer, Start Year: 2020 In this example, we demonstrated how to create nested structs ( Address inside Person ), slices of structs ( Jobs slice of Job structs), and how to access and manipulate the data within these complex data structures. Structs in Go can be as simple or as complex as needed, allowing you to model real-world entities and relationships in your code. By combining structs, slices, and other data types, you can create rich and expressive data structures tailored to your application's needs.","title":"Complex struct"},{"location":"golang/database-struct.html","text":"Sure, let's create a simple struct that resembles a database of users. In this example, we'll have a slice of User structs, and we'll define methods to perform basic CRUD (Create, Read, Update, Delete) operations on the \"database\". package main import ( \"fmt\" ) // User struct represents a user in the database type User struct { ID int Name string Email string Age int IsPremium bool } // Database is a slice to store User structs var Database []User // AddUser creates a new user and appends it to the database func AddUser(name, email string, age int, isPremium bool) { user := User{ ID: len(Database) + 1, Name: name, Email: email, Age: age, IsPremium: isPremium, } Database = append(Database, user) fmt.Println(\"User added successfully!\") } // GetUser retrieves a user from the database by ID func GetUser(id int) (User, bool) { for _, user := range Database { if user.ID == id { return user, true } } return User{}, false } // UpdateUser updates an existing user in the database func UpdateUser(id int, name, email string, age int, isPremium bool) bool { for i, user := range Database { if user.ID == id { Database[i] = User{ ID: id, Name: name, Email: email, Age: age, IsPremium: isPremium, } fmt.Printf(\"User with ID %d updated successfully!\\n\", id) return true } } fmt.Printf(\"User with ID %d not found!\\n\", id) return false } // DeleteUser removes a user from the database by ID func DeleteUser(id int) bool { for i, user := range Database { if user.ID == id { Database = append(Database[:i], Database[i+1:]...) fmt.Printf(\"User with ID %d deleted successfully!\\n\", id) return true } } fmt.Printf(\"User with ID %d not found!\\n\", id) return false } func main() { // Add some users to the database AddUser(\"John Doe\", \"john@example.com\", 30, true) AddUser(\"Jane Smith\", \"jane@example.com\", 25, false) AddUser(\"Bob Johnson\", \"bob@example.com\", 40, true) // Get a user by ID user, found := GetUser(2) if found { fmt.Printf(\"User found: %+v\\n\", user) } else { fmt.Println(\"User not found!\") } // Update a user UpdateUser(1, \"John Doe Jr.\", \"john.jr@example.com\", 31, true) // Delete a user DeleteUser(3) } In this example, we have: A User struct with ID , Name , Email , Age , and IsPremium fields. A Database slice to store User structs. AddUser function to create a new user and append it to the Database . GetUser function to retrieve a user from the Database by ID . UpdateUser function to update an existing user in the Database by ID . DeleteUser function to remove a user from the Database by ID . In the main function: We add some users to the Database using the AddUser function. We retrieve a user by ID using the GetUser function. We update a user's information using the UpdateUser function. We delete a user from the Database using the DeleteUser function. When you run this code, you'll see the following output: User added successfully! User added successfully! User added successfully! User found: {ID:2 Name:Jane Smith Email:jane@example.com Age:25 IsPremium:false} User with ID 1 updated successfully! User with ID 3 deleted successfully! In this example, we simulated a simple database using a slice of User structs. The AddUser , GetUser , UpdateUser , and DeleteUser functions represent the basic CRUD operations commonly found in database management systems. Of course, this is a very simplified example, and in real-world scenarios, you would likely use a more robust database solution like SQL or NoSQL databases. However, this example demonstrates how structs in Go can be used to model and manage data structures similar to a database.","title":"Database struct"},{"location":"golang/db-connection.html","text":"Certainly! Let's go through the steps to connect to MongoDB and PostgreSQL databases in Golang and perform basic operations. MongoDB: 1. Install the MongoDB Go driver: go get go.mongodb.org/mongo-driver/mongo Import the necessary packages in your Go file: go import ( \"context\" \"fmt\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) Connect to the MongoDB database: go clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\") client, err := mongo.Connect(context.Background(), clientOptions) if err != nil { fmt.Println(\"Error connecting to MongoDB:\", err) return } defer client.Disconnect(context.Background()) Access a specific database and collection: go database := client.Database(\"your_database_name\") collection := database.Collection(\"your_collection_name\") Perform operations (e.g., insert, find, update, delete): ```go // Insert a document doc := bson.M{\"name\": \"John\", \"age\": 30} insertResult, err := collection.InsertOne(context.Background(), doc) if err != nil { fmt.Println(\"Error inserting document:\", err) return } fmt.Println(\"Inserted document ID:\", insertResult.InsertedID) // Find documents filter := bson.M{\"age\": bson.M{\"$gte\": 25}} cur, err := collection.Find(context.Background(), filter) if err != nil { fmt.Println(\"Error finding documents:\", err) return } defer cur.Close(context.Background()) // Iterate over the retrieved documents for cur.Next(context.Background()) { var result bson.M err := cur.Decode(&result) if err != nil { fmt.Println(\"Error decoding document:\", err) return } fmt.Println(\"Found document:\", result) } ``` PostgreSQL: 1. Install the PostgreSQL driver: go get github.com/lib/pq Import the necessary package in your Go file: go import ( \"database/sql\" \"fmt\" _ \"github.com/lib/pq\" ) Connect to the PostgreSQL database: go connStr := \"user=your_username dbname=your_database_name password=your_password host=localhost sslmode=disable\" db, err := sql.Open(\"postgres\", connStr) if err != nil { fmt.Println(\"Error connecting to PostgreSQL:\", err) return } defer db.Close() Perform operations (e.g., insert, query, update, delete): ```go // Insert a record insertQuery := \"INSERT INTO users (name, age) VALUES ($1, $2)\" _, err = db.Exec(insertQuery, \"John\", 30) if err != nil { fmt.Println(\"Error inserting record:\", err) return } // Query records rows, err := db.Query(\"SELECT * FROM users WHERE age >= $1\", 25) if err != nil { fmt.Println(\"Error querying records:\", err) return } defer rows.Close() // Iterate over the retrieved records for rows.Next() { var id int var name string var age int err := rows.Scan(&id, &name, &age) if err != nil { fmt.Println(\"Error scanning record:\", err) return } fmt.Printf(\"ID: %d, Name: %s, Age: %d\\n\", id, name, age) } ``` These are the basic steps to connect to MongoDB and PostgreSQL databases in Golang and perform operations. Remember to handle errors appropriately and close","title":"Db connection"},{"location":"golang/db-crud.html","text":"Certainly! Let's extend the previous example to include the other CRUD (Create, Read, Update, Delete) operations for the users collection in the MongoDB database using Gin. package main import ( \"context\" \"fmt\" \"log\" \"net/http\" \"github.com/gin-gonic/gin\" \"go.mongodb.org/mongo-driver/bson\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) type User struct { ID primitive.ObjectID `json:\"id,omitempty\" bson:\"_id,omitempty\"` Name string `json:\"name\"` Age int `json:\"age\"` } var collection *mongo.Collection func init() { // Connect to the MongoDB database clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\") client, err := mongo.Connect(context.Background(), clientOptions) if err != nil { log.Fatal(err) } // Access the specific database and collection database := client.Database(\"your_database_name\") collection = database.Collection(\"users\") } func createUserHandler(c *gin.Context) { var user User if err := c.ShouldBindJSON(&user); err != nil { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) return } // Insert the user into the database result, err := collection.InsertOne(context.Background(), user) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } // Send a success response c.JSON(http.StatusCreated, gin.H{\"id\": result.InsertedID}) } func getUserHandler(c *gin.Context) { id := c.Param(\"id\") objectID, err := primitive.ObjectIDFromHex(id) if err != nil { c.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid user ID\"}) return } var user User err = collection.FindOne(context.Background(), bson.M{\"_id\": objectID}).Decode(&user) if err != nil { if err == mongo.ErrNoDocuments { c.JSON(http.StatusNotFound, gin.H{\"error\": \"User not found\"}) } else { c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) } return } c.JSON(http.StatusOK, user) } func updateUserHandler(c *gin.Context) { id := c.Param(\"id\") objectID, err := primitive.ObjectIDFromHex(id) if err != nil { c.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid user ID\"}) return } var user User if err := c.ShouldBindJSON(&user); err != nil { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) return } update := bson.M{ \"$set\": bson.M{ \"name\": user.Name, \"age\": user.Age, }, } _, err = collection.UpdateOne(context.Background(), bson.M{\"_id\": objectID}, update) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } c.JSON(http.StatusOK, gin.H{\"message\": \"User updated successfully\"}) } func deleteUserHandler(c *gin.Context) { id := c.Param(\"id\") objectID, err := primitive.ObjectIDFromHex(id) if err != nil { c.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid user ID\"}) return } _, err = collection.DeleteOne(context.Background(), bson.M{\"_id\": objectID}) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } c.JSON(http.StatusOK, gin.H{\"message\": \"User deleted successfully\"}) } func main() { router := gin.Default() router.POST(\"/users\", createUserHandler) router.GET(\"/users/:id\", getUserHandler) router.PUT(\"/users/:id\", updateUserHandler) router.DELETE(\"/users/:id\", deleteUserHandler) fmt.Println(\"Server is running on port 8080\") log.Fatal(router.Run(\":8080\")) } In this updated example, we have added the following CRUD operations: Create (POST /users ): The createUserHandler function handles the creation of a new user. It binds the JSON request body to the user struct using c.ShouldBindJSON(&user) . It inserts the user into the users collection using collection.InsertOne() . It sends a success response with the inserted user's ID. Read (GET /users/:id ): The getUserHandler function handles retrieving a user by ID. It extracts the user ID from the URL parameter using c.Param(\"id\") . It converts the ID string to an ObjectID using primitive.ObjectIDFromHex() . It finds the user in the users collection using collection.FindOne() . It sends the user as a JSON response if found, or an appropriate error response. Update (PUT /users/:id ): The updateUserHandler function handles updating a user by ID. It extracts the user ID from the URL parameter and converts it to an ObjectID . It binds the JSON request body to the user struct. It creates an update document using bson.M to specify the fields to update. It updates the user in the users collection using collection.UpdateOne() . It sends a success response indicating that the user was updated successfully. Delete (DELETE /users/:id ): The deleteUserHandler function handles deleting a user by ID. It extracts the user ID from the URL parameter and converts it to an ObjectID . It deletes the user from the users collection using collection.DeleteOne() . It sends a success response indicating that the user was deleted successfully. The init() function is used to establish a connection to the MongoDB database when the program starts. It connects to the specified MongoDB server and sets the collection variable to the users collection. The main() function sets up the Gin router and defines the routes for each CRUD operation, mapping them to the corresponding handler functions. You can test these endpoints using Postman by sending appropriate requests to the specified routes ( /users for create and /users/:id for read, update, and delete operations) with the required JSON payloads. Remember to replace \"your_database_name\" with the actual name of your MongoDB database.","title":"Db crud"},{"location":"golang/file-operations.html","text":"Certainly! Here are some common file operations using the os package and other modules in Go, taking into account that ioutil is deprecated: Reading a file: package main import ( \"fmt\" \"os\" ) func main() { file, err := os.Open(\"file.txt\") if err != nil { fmt.Println(\"Error opening file:\", err) return } defer file.Close() // Read the file content content, err := os.ReadFile(\"file.txt\") if err != nil { fmt.Println(\"Error reading file:\", err) return } fmt.Println(string(content)) } Writing to a file: package main import ( \"fmt\" \"os\" ) func main() { content := []byte(\"Hello, World!\") err := os.WriteFile(\"file.txt\", content, 0644) if err != nil { fmt.Println(\"Error writing to file:\", err) return } fmt.Println(\"File written successfully.\") } Appending to a file: package main import ( \"fmt\" \"os\" ) func main() { file, err := os.OpenFile(\"file.txt\", os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Println(\"Error opening file:\", err) return } defer file.Close() content := []byte(\"Appended content.\\n\") _, err = file.Write(content) if err != nil { fmt.Println(\"Error appending to file:\", err) return } fmt.Println(\"Content appended successfully.\") } Copying a file: package main import ( \"fmt\" \"io\" \"os\" ) func main() { sourceFile, err := os.Open(\"source.txt\") if err != nil { fmt.Println(\"Error opening source file:\", err) return } defer sourceFile.Close() destinationFile, err := os.Create(\"destination.txt\") if err != nil { fmt.Println(\"Error creating destination file:\", err) return } defer destinationFile.Close() _, err = io.Copy(destinationFile, sourceFile) if err != nil { fmt.Println(\"Error copying file:\", err) return } fmt.Println(\"File copied successfully.\") } Deleting a file: package main import ( \"fmt\" \"os\" ) func main() { err := os.Remove(\"file.txt\") if err != nil { fmt.Println(\"Error deleting file:\", err) return } fmt.Println(\"File deleted successfully.\") } These examples demonstrate some common file operations using the os package and other modules in Go. The os package provides functions for opening, reading, writing, appending, and deleting files, while the io package is used for copying files. Note that error handling is important when working with files to ensure proper execution and graceful handling of any issues that may arise. Certainly! Here's an example of working with CSV files in Go using the encoding/csv package: Reading from a CSV file: package main import ( \"encoding/csv\" \"fmt\" \"os\" ) func main() { file, err := os.Open(\"data.csv\") if err != nil { fmt.Println(\"Error opening CSV file:\", err) return } defer file.Close() reader := csv.NewReader(file) data, err := reader.ReadAll() if err != nil { fmt.Println(\"Error reading CSV data:\", err) return } for _, row := range data { fmt.Println(row) } } In this example, we open a CSV file named \"data.csv\" using os.Open() . We then create a new CSV reader using csv.NewReader() and read all the data from the file using reader.ReadAll() . Finally, we iterate over each row of the CSV data and print it. Writing to a CSV file: package main import ( \"encoding/csv\" \"fmt\" \"os\" ) func main() { data := [][]string{ {\"Name\", \"Age\", \"City\"}, {\"John\", \"30\", \"New York\"}, {\"Alice\", \"25\", \"London\"}, {\"Bob\", \"35\", \"Paris\"}, } file, err := os.Create(\"output.csv\") if err != nil { fmt.Println(\"Error creating CSV file:\", err) return } defer file.Close() writer := csv.NewWriter(file) defer writer.Flush() for _, row := range data { err := writer.Write(row) if err != nil { fmt.Println(\"Error writing to CSV:\", err) return } } fmt.Println(\"CSV file created successfully.\") } In this example, we have a slice of string slices called data representing the CSV data we want to write. We create a new CSV file named \"output.csv\" using os.Create() . We then create a new CSV writer using csv.NewWriter() . We iterate over each row of the data slice and write it to the CSV file using writer.Write() . After writing all the rows, we call writer.Flush() to ensure that all the data is written to the file. Customizing CSV options: package main import ( \"encoding/csv\" \"fmt\" \"os\" ) func main() { file, err := os.Open(\"data.csv\") if err != nil { fmt.Println(\"Error opening CSV file:\", err) return } defer file.Close() reader := csv.NewReader(file) reader.Comma = ';' // Set custom delimiter reader.Comment = '#' // Set custom comment character data, err := reader.ReadAll() if err != nil { fmt.Println(\"Error reading CSV data:\", err) return } for _, row := range data { fmt.Println(row) } } In this example, we demonstrate how to customize the CSV options. We set the Comma field of the CSV reader to ; to specify a custom delimiter, and we set the Comment field to # to specify a custom comment character. These examples cover the basic operations of reading from and writing to CSV files in Go using the encoding/csv package. You can further customize the CSV options and handle different scenarios based on your specific requirements.","title":"File operations"},{"location":"golang/file-operations.html#certainly-heres-an-example-of-working-with-csv-files-in-go-using-the-encodingcsv-package","text":"Reading from a CSV file: package main import ( \"encoding/csv\" \"fmt\" \"os\" ) func main() { file, err := os.Open(\"data.csv\") if err != nil { fmt.Println(\"Error opening CSV file:\", err) return } defer file.Close() reader := csv.NewReader(file) data, err := reader.ReadAll() if err != nil { fmt.Println(\"Error reading CSV data:\", err) return } for _, row := range data { fmt.Println(row) } } In this example, we open a CSV file named \"data.csv\" using os.Open() . We then create a new CSV reader using csv.NewReader() and read all the data from the file using reader.ReadAll() . Finally, we iterate over each row of the CSV data and print it. Writing to a CSV file: package main import ( \"encoding/csv\" \"fmt\" \"os\" ) func main() { data := [][]string{ {\"Name\", \"Age\", \"City\"}, {\"John\", \"30\", \"New York\"}, {\"Alice\", \"25\", \"London\"}, {\"Bob\", \"35\", \"Paris\"}, } file, err := os.Create(\"output.csv\") if err != nil { fmt.Println(\"Error creating CSV file:\", err) return } defer file.Close() writer := csv.NewWriter(file) defer writer.Flush() for _, row := range data { err := writer.Write(row) if err != nil { fmt.Println(\"Error writing to CSV:\", err) return } } fmt.Println(\"CSV file created successfully.\") } In this example, we have a slice of string slices called data representing the CSV data we want to write. We create a new CSV file named \"output.csv\" using os.Create() . We then create a new CSV writer using csv.NewWriter() . We iterate over each row of the data slice and write it to the CSV file using writer.Write() . After writing all the rows, we call writer.Flush() to ensure that all the data is written to the file. Customizing CSV options: package main import ( \"encoding/csv\" \"fmt\" \"os\" ) func main() { file, err := os.Open(\"data.csv\") if err != nil { fmt.Println(\"Error opening CSV file:\", err) return } defer file.Close() reader := csv.NewReader(file) reader.Comma = ';' // Set custom delimiter reader.Comment = '#' // Set custom comment character data, err := reader.ReadAll() if err != nil { fmt.Println(\"Error reading CSV data:\", err) return } for _, row := range data { fmt.Println(row) } } In this example, we demonstrate how to customize the CSV options. We set the Comma field of the CSV reader to ; to specify a custom delimiter, and we set the Comment field to # to specify a custom comment character. These examples cover the basic operations of reading from and writing to CSV files in Go using the encoding/csv package. You can further customize the CSV options and handle different scenarios based on your specific requirements.","title":"Certainly! Here's an example of working with CSV files in Go using the encoding/csv package:"},{"location":"golang/func-breakdown.html","text":"Variable address passing In this example, we have two variables, name and age, that we want to read from the terminal. Here's how it works: We use the fmt.Print() function to prompt the user to enter their name. We then use fmt.Scan(&name) to read the user's input and store it in the name variable. The & symbol is used to pass the address of the variable to the Scan() function. We check for any errors that may have occurred during the input reading process using the returned error value. We repeat the same process for the age variable, using fmt.Scan(&age) to read the user's input. Finally, we use fmt.Printf() to print the user's name and age. Alternatively, you can use the fmt.Scanln() function, which reads input until a newline character is encountered: fmt.Print(\"Enter your name and age: \") _, err := fmt.Scanln(&name, &age) if err != nil { fmt.Println(\"Error:\", err) return } In this case, the user can enter their name and age on the same line, separated by a space, and the input will be read correctly. Remember that the Scan() and Scanln() functions return the number of successfully scanned items and an error value, so it's important to check for any errors that may have occurred during the input reading process. Certainly! Let's break down the fmt.Scan() function: fmt.Scan(a ...any) (n int, err error) This is the function signature of fmt.Scan() . a ...any is a variadic parameter, which means it can accept any number of arguments of any type. The function returns two values: n int : The number of successfully scanned items. err error : An error value, if any, that occurred during the scanning process. fmt.Scan(&name, &age) In this example, we're passing two variables, name and age , to the Scan() function. The & symbol is used to pass the address of the variables, so that the Scan() function can modify their values directly. The Scan() function will read the user's input and store the values in the name and age variables. _, err := fmt.Scan(&name, &age) Here, we're using the short variable declaration syntax ( := ) to declare two variables: _ and err . The _ is an unnamed variable, which is used to discard the first return value (the number of successfully scanned items). The err variable is used to store the error value returned by the Scan() function. if err != nil { ... } After calling fmt.Scan() , we check if an error occurred during the scanning process. If err is not nil , it means an error occurred, and we can handle it accordingly (e.g., print an error message, return from the function, etc.). In summary, the fmt.Scan() function is used to read user input from the terminal and store the values in the provided variables. It returns the number of successfully scanned items and an error value, which you should always check to ensure that the input was read correctly.","title":"Func breakdown"},{"location":"golang/func-breakdown.html#variable-address-passing","text":"In this example, we have two variables, name and age, that we want to read from the terminal. Here's how it works: We use the fmt.Print() function to prompt the user to enter their name. We then use fmt.Scan(&name) to read the user's input and store it in the name variable. The & symbol is used to pass the address of the variable to the Scan() function. We check for any errors that may have occurred during the input reading process using the returned error value. We repeat the same process for the age variable, using fmt.Scan(&age) to read the user's input. Finally, we use fmt.Printf() to print the user's name and age. Alternatively, you can use the fmt.Scanln() function, which reads input until a newline character is encountered: fmt.Print(\"Enter your name and age: \") _, err := fmt.Scanln(&name, &age) if err != nil { fmt.Println(\"Error:\", err) return } In this case, the user can enter their name and age on the same line, separated by a space, and the input will be read correctly. Remember that the Scan() and Scanln() functions return the number of successfully scanned items and an error value, so it's important to check for any errors that may have occurred during the input reading process.","title":"Variable address passing"},{"location":"golang/func-breakdown.html#certainly-lets-break-down-the-fmtscan-function","text":"fmt.Scan(a ...any) (n int, err error) This is the function signature of fmt.Scan() . a ...any is a variadic parameter, which means it can accept any number of arguments of any type. The function returns two values: n int : The number of successfully scanned items. err error : An error value, if any, that occurred during the scanning process. fmt.Scan(&name, &age) In this example, we're passing two variables, name and age , to the Scan() function. The & symbol is used to pass the address of the variables, so that the Scan() function can modify their values directly. The Scan() function will read the user's input and store the values in the name and age variables. _, err := fmt.Scan(&name, &age) Here, we're using the short variable declaration syntax ( := ) to declare two variables: _ and err . The _ is an unnamed variable, which is used to discard the first return value (the number of successfully scanned items). The err variable is used to store the error value returned by the Scan() function. if err != nil { ... } After calling fmt.Scan() , we check if an error occurred during the scanning process. If err is not nil , it means an error occurred, and we can handle it accordingly (e.g., print an error message, return from the function, etc.). In summary, the fmt.Scan() function is used to read user input from the terminal and store the values in the provided variables. It returns the number of successfully scanned items and an error value, which you should always check to ensure that the input was read correctly.","title":"Certainly! Let's break down the fmt.Scan() function:"},{"location":"golang/json.html","text":"Certainly! Here are a few examples of working with JSON in Go using the encoding/json package: Encoding JSON: package main import ( \"encoding/json\" \"fmt\" ) type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` Email string `json:\"email\"` } func main() { person := Person{ Name: \"John Doe\", Age: 30, Email: \"john@example.com\", } jsonData, err := json.Marshal(person) if err != nil { fmt.Println(\"Error encoding JSON:\", err) return } fmt.Println(string(jsonData)) } In this example, we define a Person struct with fields Name , Age , and Email . We create an instance of the Person struct and then use json.Marshal() to encode it into a JSON byte slice. Finally, we convert the byte slice to a string and print it. Decoding JSON: package main import ( \"encoding/json\" \"fmt\" ) type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` Email string `json:\"email\"` } func main() { jsonData := []byte(`{\"name\":\"John Doe\",\"age\":30,\"email\":\"john@example.com\"}`) var person Person err := json.Unmarshal(jsonData, &person) if err != nil { fmt.Println(\"Error decoding JSON:\", err) return } fmt.Println(person) } In this example, we have a JSON byte slice jsonData . We define a Person struct to hold the decoded data. We use json.Unmarshal() to decode the JSON data into the person struct. Finally, we print the person struct. Working with JSON files: package main import ( \"encoding/json\" \"fmt\" \"os\" ) type Config struct { Host string `json:\"host\"` Port int `json:\"port\"` Username string `json:\"username\"` Password string `json:\"password\"` } func main() { file, err := os.Open(\"config.json\") if err != nil { fmt.Println(\"Error opening JSON file:\", err) return } defer file.Close() var config Config decoder := json.NewDecoder(file) err = decoder.Decode(&config) if err != nil { fmt.Println(\"Error decoding JSON:\", err) return } fmt.Println(config) } In this example, we have a JSON file named \"config.json\". We open the file using os.Open() and create a new JSON decoder using json.NewDecoder() . We then use decoder.Decode() to decode the JSON data from the file into the config struct. Finally, we print the config struct. These examples demonstrate the basic operations of encoding and decoding JSON in Go using the encoding/json package. You can customize the struct tags to control the field names in the JSON output, handle nested structures, and work with different JSON formats based on your specific requirements.","title":"Json"},{"location":"golang/methods.html","text":"Sure, let's go through another example to create methods in Go step by step: First, we'll define a struct called Rectangle with two fields: length and width . type Rectangle struct { length float64 width float64 } Next, we'll create a method called area that calculates the area of a rectangle. To define a method, we use the syntax func (receiver_name receiver_type) method_name(parameters) return_type { ... } . func (r Rectangle) area() float64 { return r.length * r.width } Here, r is the receiver name (an instance of Rectangle ), and Rectangle is the receiver type. The method area takes no parameters and returns a float64 value. Inside the method, we use r.length and r.width to access the length and width fields of the Rectangle instance r . Let's define another method called perimeter that calculates the perimeter of a rectangle. func (r Rectangle) perimeter() float64 { return 2 * (r.length + r.width) } This method follows the same structure as the area method. Now, let's create an instance of the Rectangle struct and call its methods. func main() { rect := Rectangle{length: 5.0, width: 3.0} fmt.Println(\"Area:\", rect.area()) fmt.Println(\"Perimeter:\", rect.perimeter()) } In the main function, we create a Rectangle instance with length 5.0 and width 3.0. Then, we call the area and perimeter methods on this instance using the dot notation ( rect.area() and rect.perimeter() ). The complete code looks like this: package main import \"fmt\" type Rectangle struct { length float64 width float64 } func (r Rectangle) area() float64 { return r.length * r.width } func (r Rectangle) perimeter() float64 { return 2 * (r.length + r.width) } func main() { rect := Rectangle{length: 5.0, width: 3.0} fmt.Println(\"Area:\", rect.area()) fmt.Println(\"Perimeter:\", rect.perimeter()) } When you run this code, it will output: Area: 15 Perimeter: 16 In this example, we defined two methods ( area and perimeter ) on the Rectangle struct. These methods operate on instances of the Rectangle struct and perform calculations based on the length and width fields. To call a method, you use the dot notation ( instance.method_name() ) on an instance of the struct. The method has access to the fields of the instance through the receiver ( r in this case).","title":"Methods"},{"location":"golang/pointers-dereferencing.html","text":"Sure! Pointers and dereferencing are fundamental concepts in programming, especially in languages like Go, C, and C++. Let's go through a detailed explanation with examples. What is a Pointer? A pointer is a variable that holds the memory address of another variable. Instead of storing a data value directly, a pointer stores the address where the value is located. Declaration of a Pointer In Go, you declare a pointer by using the * operator. Here's a basic example: package main import ( \"fmt\" ) func main() { var x int = 10 var p *int p = &x fmt.Println(\"Value of x:\", x) fmt.Println(\"Address of x:\", &x) fmt.Println(\"Value of p (address of x):\", p) fmt.Println(\"Value at the address stored in p:\", *p) } Explanation: var x int = 10 : Declare an integer variable x with a value of 10. var p *int : Declare a pointer variable p that can hold the address of an integer. p = &x : The & operator is used to get the address of the variable x . This address is assigned to p . fmt.Println(\"Value of x:\", x) : Prints the value of x , which is 10. fmt.Println(\"Address of x:\", &x) : Prints the memory address of x . fmt.Println(\"Value of p (address of x):\", p) : Prints the value of p , which is the address of x . fmt.Println(\"Value at the address stored in p:\", *p) : The * operator is used to dereference the pointer p . It gives the value stored at the address held by p , which is 10. Pointers with Functions Using pointers with functions allows you to modify the original value of a variable from within the function. Here's an example to illustrate this: package main import ( \"fmt\" ) func main() { var x int = 10 fmt.Println(\"Before change:\", x) changeValue(&x) fmt.Println(\"After change:\", x) } func changeValue(p *int) { *p = 20 } Explanation: changeValue(&x) : Passes the address of x to the changeValue function. func changeValue(p *int) : The function takes a pointer to an integer as a parameter. *p = 20 : Dereferences the pointer p and changes the value at the address p points to. This effectively changes the value of x to 20. Practical Example: Swapping Values A practical example of using pointers is to swap the values of two variables: package main import ( \"fmt\" ) func main() { a := 5 b := 10 fmt.Println(\"Before swap: a =\", a, \"b =\", b) swap(&a, &b) fmt.Println(\"After swap: a =\", a, \"b =\", b) } func swap(x, y *int) { temp := *x *x = *y *y = temp } Explanation: swap(&a, &b) : Passes the addresses of a and b to the swap function. func swap(x, y *int) : The function takes two pointers to integers as parameters. temp := *x : Dereferences x to get the value of a and stores it in temp . *x = *y : Dereferences y to get the value of b and assigns it to a . *y = temp : Assigns the value of temp (original value of a ) to b . Summary: Pointer ( *int ) : A variable that holds the memory address of an integer. Address-of ( &x ) : Operator to get the address of variable x . Dereference ( *p ) : Operator to access the value stored at the address in pointer p . Using pointers allows for more efficient memory usage and the ability to modify variables directly within functions, making your programs more powerful and flexible.","title":"Pointers dereferencing"},{"location":"golang/pointers-dereferencing.html#what-is-a-pointer","text":"A pointer is a variable that holds the memory address of another variable. Instead of storing a data value directly, a pointer stores the address where the value is located.","title":"What is a Pointer?"},{"location":"golang/pointers-dereferencing.html#declaration-of-a-pointer","text":"In Go, you declare a pointer by using the * operator. Here's a basic example: package main import ( \"fmt\" ) func main() { var x int = 10 var p *int p = &x fmt.Println(\"Value of x:\", x) fmt.Println(\"Address of x:\", &x) fmt.Println(\"Value of p (address of x):\", p) fmt.Println(\"Value at the address stored in p:\", *p) }","title":"Declaration of a Pointer"},{"location":"golang/pointers-dereferencing.html#explanation","text":"var x int = 10 : Declare an integer variable x with a value of 10. var p *int : Declare a pointer variable p that can hold the address of an integer. p = &x : The & operator is used to get the address of the variable x . This address is assigned to p . fmt.Println(\"Value of x:\", x) : Prints the value of x , which is 10. fmt.Println(\"Address of x:\", &x) : Prints the memory address of x . fmt.Println(\"Value of p (address of x):\", p) : Prints the value of p , which is the address of x . fmt.Println(\"Value at the address stored in p:\", *p) : The * operator is used to dereference the pointer p . It gives the value stored at the address held by p , which is 10.","title":"Explanation:"},{"location":"golang/pointers-dereferencing.html#pointers-with-functions","text":"Using pointers with functions allows you to modify the original value of a variable from within the function. Here's an example to illustrate this: package main import ( \"fmt\" ) func main() { var x int = 10 fmt.Println(\"Before change:\", x) changeValue(&x) fmt.Println(\"After change:\", x) } func changeValue(p *int) { *p = 20 }","title":"Pointers with Functions"},{"location":"golang/pointers-dereferencing.html#explanation_1","text":"changeValue(&x) : Passes the address of x to the changeValue function. func changeValue(p *int) : The function takes a pointer to an integer as a parameter. *p = 20 : Dereferences the pointer p and changes the value at the address p points to. This effectively changes the value of x to 20.","title":"Explanation:"},{"location":"golang/pointers-dereferencing.html#practical-example-swapping-values","text":"A practical example of using pointers is to swap the values of two variables: package main import ( \"fmt\" ) func main() { a := 5 b := 10 fmt.Println(\"Before swap: a =\", a, \"b =\", b) swap(&a, &b) fmt.Println(\"After swap: a =\", a, \"b =\", b) } func swap(x, y *int) { temp := *x *x = *y *y = temp }","title":"Practical Example: Swapping Values"},{"location":"golang/pointers-dereferencing.html#explanation_2","text":"swap(&a, &b) : Passes the addresses of a and b to the swap function. func swap(x, y *int) : The function takes two pointers to integers as parameters. temp := *x : Dereferences x to get the value of a and stores it in temp . *x = *y : Dereferences y to get the value of b and assigns it to a . *y = temp : Assigns the value of temp (original value of a ) to b .","title":"Explanation:"},{"location":"golang/pointers-dereferencing.html#summary","text":"Pointer ( *int ) : A variable that holds the memory address of an integer. Address-of ( &x ) : Operator to get the address of variable x . Dereference ( *p ) : Operator to access the value stored at the address in pointer p . Using pointers allows for more efficient memory usage and the ability to modify variables directly within functions, making your programs more powerful and flexible.","title":"Summary:"},{"location":"golang/struct.html","text":"Sure, I'd be happy to teach you about structs in Go (Golang). A struct is a user-defined data type that allows you to group related pieces of data together in a single unit. It's similar to classes in object-oriented programming languages, but in Go, they are simpler and more lightweight. Here's an example of defining a struct in Go: type Person struct { Name string Age int Email string } In this example, we define a Person struct with three fields: Name , Age , and Email . Each field has a name and a type. To create an instance of the Person struct, you can use the struct literal syntax: person1 := Person{ Name: \"John Doe\", Age: 30, Email: \"john@example.com\", } You can also create a new struct instance using the new keyword, and then assign values to the fields: person2 := new(Person) person2.Name = \"Jane Smith\" person2.Age = 25 person2.Email = \"jane@example.com\" Once you have a struct instance, you can access its fields using the dot notation: fmt.Println(person1.Name) // Output: John Doe fmt.Println(person2.Age) // Output: 25 Structs in Go can also have methods associated with them, which are functions that operate on instances of the struct. Here's an example: type Person struct { Name string Age int } func (p Person) Greet() string { return \"Hi, my name is \" + p.Name } func main() { person1 := Person{ Name: \"John Doe\", Age: 30, } greeting := person1.Greet() fmt.Println(greeting) // Output: Hi, my name is John Doe } In this example, we define a Greet method on the Person struct. Methods are defined similarly to functions, but they take a receiver argument ( p Person in this case) which represents the instance of the struct on which the method is called. Structs in Go can be nested, meaning that you can have a struct field that is another struct type. This allows you to create complex data structures. type Address struct { Street string City string State string } type Person struct { Name string Age int Address Address } In this example, the Person struct has a field Address which is of type Address (another struct). Structs are widely used in Go for representing and organizing data in a structured way. They are lightweight and efficient, making them a powerful tool for building complex applications.","title":"Struct"},{"location":"golang/projects/1-Simple-CLI-Tool.html","text":"1. Simple CLI Tool: Project: Create a command-line tool that performs a specific task, such as: Checking the status of a service (e.g., a web server) Converting files between formats (e.g., text to JSON) Generating random passwords Learning: This project introduces you to basic Go syntax, handling command-line arguments, and interacting with the operating system.","title":"1 Simple CLI Tool"},{"location":"golang/projects/2-Web-Server-with-Basic-API.html","text":"2. Web Server with Basic API: Project: Build a simple web server with a basic REST API that: Serves static content (HTML, CSS, JavaScript) Exposes endpoints for simple operations (e.g., returning data, performing calculations) Learning: You'll learn how to work with web frameworks (e.g., Gin, Echo), handle HTTP requests and responses, and create basic APIs.","title":"2 Web Server with Basic API"},{"location":"golang/projects/3-Simple-Monitoring-Script.html","text":"3. Simple Monitoring Script: Project: Create a script that monitors a system metric (e.g., CPU usage, disk space) and sends alerts if it exceeds a threshold. Learning: This project covers working with system metrics, setting up timers, and sending notifications (e.g., email, Slack).","title":"3 Simple Monitoring Script"},{"location":"golang/projects/4-Container-Image-Builder.html","text":"4. Container Image Builder: Project: Build a tool that creates Docker images for your application. This tool can: Take a directory containing your application code and dependencies as input. Create a Dockerfile based on a base image. Build a container image and push it to a registry. Learning: You'll learn about Docker and containerization, working with Dockerfiles, and automating container image creation.","title":"4 Container Image Builder"},{"location":"golang/projects/5-Simple-Chat-Server.html","text":"5. Simple Chat Server: Project: Build a basic chat server using Go's concurrency features. This server can: Accept connections from multiple clients. Allow clients to send and receive messages. Handle message broadcasting to all connected clients. Learning: You'll learn about network programming, handling multiple connections, and using Go's goroutines and channels for concurrency.","title":"5 Simple Chat Server"},{"location":"golang/projects/6-Data-Processing-Script.html","text":"6. Data Processing Script: Project: Write a script that processes data from a file or a database (e.g., CSV file, JSON file). This script can: Parse data from the source. Perform transformations (e.g., filtering, aggregation). Output the processed data to a new file or a database. Learning: This project introduces you to file I/O, data parsing, working with databases (e.g., MySQL, PostgreSQL), and data manipulation.","title":"6 Data Processing Script"},{"location":"golang/projects/7-color-print-message.html","text":"1. https://pkg.go.dev/github.com/fatih/color#pkg-overview // you can use github.com/fatih/color package as well color.Green(\"Bright green color.\") 2. To achieve the same functionality in Go, you can use the fmt package and ANSI escape codes for color formatting. Here's the equivalent code in Go: package main import \"fmt\" func color(colorName string) { switch colorName { case \"red\": fmt.Print(\"\\033[31m\") case \"green\": fmt.Print(\"\\033[32m\") case \"yellow\": fmt.Print(\"\\033[33m\") default: fmt.Print(\"\\033[0m\") } } func main() { color(\"green\") fmt.Println(\"hello\") color(\"reset\") } Explanation: - The color function takes a colorName string parameter and uses a switch statement to determine the corresponding ANSI escape code for the color. - The ANSI escape codes are used to set the color of the text in the terminal: - \\033[31m sets the color to red. - \\033[32m sets the color to green. - \\033[33m sets the color to yellow. - \\033[0m resets the color to the default. - In the main function, we call the color function with the desired color name before printing the text. - After printing the colored text, we call color(\"reset\") to reset the color to the default. Note: The ANSI escape codes used in this code are widely supported by most modern terminals. However, if you're using an older terminal or a terminal that doesn't support ANSI escape codes, the colors may not be displayed correctly. When you run this Go code, it will output \"hello\" in green color in the terminal. The ANSI escape codes used for coloring the text in the terminal are part of the ANSI (American National Standards Institute) standard. These codes are not specific to Go, but rather a widely adopted standard for controlling text formatting, colors, and other attributes in command-line interfaces. While there isn't a single official documentation for ANSI escape codes, you can find information about them from various sources. Here are a few links that provide detailed explanations and references for ANSI escape codes: Wikipedia - ANSI escape code: https://en.wikipedia.org/wiki/ANSI_escape_code ASCII Table - ANSI Escape sequences: https://ascii-table.com/ansi-escape-sequences.php Bash Hackers Wiki - ANSI Escape Sequences: https://wiki.bash-hackers.org/scripting/terminalcodes Xterm Control Sequences: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html ANSI Escape Code - Colored Text: https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797 These resources provide detailed information about ANSI escape codes, including the codes for different colors, text styles (bold, italic, underline), cursor movement, and more. Keep in mind that while ANSI escape codes are widely supported, their interpretation may vary slightly across different terminals and operating systems. It's always a good idea to test your code in the target environment to ensure the desired formatting is displayed correctly.","title":"1. https://pkg.go.dev/github.com/fatih/color#pkg-overview"},{"location":"golang/projects/7-color-print-message.html#1-httpspkggodevgithubcomfatihcolorpkg-overview","text":"// you can use github.com/fatih/color package as well color.Green(\"Bright green color.\")","title":"1. https://pkg.go.dev/github.com/fatih/color#pkg-overview"},{"location":"golang/projects/7-color-print-message.html#2-to-achieve-the-same-functionality-in-go-you-can-use-the-fmt-package-and-ansi-escape-codes-for-color-formatting-heres-the-equivalent-code-in-go","text":"package main import \"fmt\" func color(colorName string) { switch colorName { case \"red\": fmt.Print(\"\\033[31m\") case \"green\": fmt.Print(\"\\033[32m\") case \"yellow\": fmt.Print(\"\\033[33m\") default: fmt.Print(\"\\033[0m\") } } func main() { color(\"green\") fmt.Println(\"hello\") color(\"reset\") } Explanation: - The color function takes a colorName string parameter and uses a switch statement to determine the corresponding ANSI escape code for the color. - The ANSI escape codes are used to set the color of the text in the terminal: - \\033[31m sets the color to red. - \\033[32m sets the color to green. - \\033[33m sets the color to yellow. - \\033[0m resets the color to the default. - In the main function, we call the color function with the desired color name before printing the text. - After printing the colored text, we call color(\"reset\") to reset the color to the default. Note: The ANSI escape codes used in this code are widely supported by most modern terminals. However, if you're using an older terminal or a terminal that doesn't support ANSI escape codes, the colors may not be displayed correctly. When you run this Go code, it will output \"hello\" in green color in the terminal.","title":"2. To achieve the same functionality in Go, you can use the fmt package and ANSI escape codes for color formatting. Here's the equivalent code in Go:"},{"location":"golang/projects/7-color-print-message.html#the-ansi-escape-codes-used-for-coloring-the-text-in-the-terminal-are-part-of-the-ansi-american-national-standards-institute-standard-these-codes-are-not-specific-to-go-but-rather-a-widely-adopted-standard-for-controlling-text-formatting-colors-and-other-attributes-in-command-line-interfaces","text":"While there isn't a single official documentation for ANSI escape codes, you can find information about them from various sources. Here are a few links that provide detailed explanations and references for ANSI escape codes: Wikipedia - ANSI escape code: https://en.wikipedia.org/wiki/ANSI_escape_code ASCII Table - ANSI Escape sequences: https://ascii-table.com/ansi-escape-sequences.php Bash Hackers Wiki - ANSI Escape Sequences: https://wiki.bash-hackers.org/scripting/terminalcodes Xterm Control Sequences: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html ANSI Escape Code - Colored Text: https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797 These resources provide detailed information about ANSI escape codes, including the codes for different colors, text styles (bold, italic, underline), cursor movement, and more. Keep in mind that while ANSI escape codes are widely supported, their interpretation may vary slightly across different terminals and operating systems. It's always a good idea to test your code in the target environment to ensure the desired formatting is displayed correctly.","title":"The ANSI escape codes used for coloring the text in the terminal are part of the ANSI (American National Standards Institute) standard. These codes are not specific to Go, but rather a widely adopted standard for controlling text formatting, colors, and other attributes in command-line interfaces."},{"location":"kubernetes/kubernetes.html","text":"kubernetes","title":"kubernetes"},{"location":"kubernetes/kubernetes.html#kubernetes","text":"","title":"kubernetes"},{"location":"logging/logging.html","text":"logging","title":"logging"},{"location":"logging/logging.html#logging","text":"","title":"logging"},{"location":"monitoring/monitoring.html","text":"monitoring","title":"monitoring"},{"location":"monitoring/monitoring.html#monitoring","text":"","title":"monitoring"},{"location":"networking/networking.html","text":"","title":"Networking"},{"location":"rendering/CSR.html","text":"Client-Side Rendering (CSR) with Create React App For the CSR example, we'll use Create React App, which provides a production build process that generates optimized static files. Build the React app for production: First, let's create a new React app using create-react-app: npx create-react-app my-csr-app cd my-csr-app npm run build This will generate a build folder containing the optimized static files. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; root /usr/share/nginx/html; index index.html; location / { try_files $uri $uri/ /index.html; } } } This Nginx configuration serves the static files from the build folder and handles client-side routing correctly. Create a Dockerfile: FROM nginx:latest COPY build /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf This Dockerfile copies the build folder to the appropriate location inside the Nginx image and replaces the default Nginx configuration with the one we created. Build and run the Docker container: docker build -t my-csr-app . docker run -p 80:80 my-csr-app version: '3' services: app: build: . ports: - '3000:3000' volumes: - ./:/app - /app/node_modules This will build the Docker image and run a container that serves the CSR app on http://localhost .","title":"CSR"},{"location":"rendering/ISR.html","text":"Incremental Static Regeneration (ISR) For ISR, we'll use a combination of Nginx and a Next.js server to handle the static serving and incremental regeneration. Build the Next.js app for production: npm run build This will generate an optimized production build in the .next folder. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } } This Nginx configuration proxies all requests to the Next.js server running on http://localhost:3000 . Create a Dockerfile: FROM node:14-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build ENV NODE_ENV production CMD [\"npm\", \"start\"] FROM nginx:latest COPY --from=0 /app/.next /app/.next COPY --from=0 /app/nginx.conf /etc/nginx/conf.d/default.conf This multi-stage Dockerfile first builds the Next.js app using the Node.js base image, and then copies the built .next folder and the Nginx configuration to the Nginx image. Build and run the Docker container: docker build -t my-isr-app . docker run -p 80:80 my-isr-app This will build the Docker image and run a container that serves the Next.js app with ISR on http://localhost . Nginx will proxy requests to the Next.js server, which will serve the static pages and incrementally regenerate the dynamic pages as needed. In the ISR setup, the Next.js server is responsible for handling the incremental regeneration of pages, while Nginx serves as a reverse proxy and caches the static pages for better performance. Note that for both SSG and ISR, you'll need to configure the appropriate settings in your Next.js app to specify which pages should be statically generated and which pages should use ISR. You can refer to the Next.js documentation for more information on these settings. Additionally, in a production environment, you might want to separate the Nginx and Next.js server into different containers for better scalability and resource management, and possibly add a load balancer or reverse proxy in front of the containers for better load handling and failover. These examples should give you a good starting point for setting up production-ready Static Site Generation (SSG) and Incremental Static Regeneration (ISR) applications using Next.js, Docker, and Nginx. You can further customize the configurations based on your specific requirements, such as adding HTTPS support, configuring caching, or setting up a reverse proxy.","title":"ISR"},{"location":"rendering/SSG.html","text":"Static Site Generation (SSG) Build the Next.js app for production: npm run build This will generate a static version of your Next.js app in the .next/static folder. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; root /usr/share/nginx/html; index index.html; location / { try_files $uri $uri/ /index.html; } } } This Nginx configuration serves the static files from the .next/static folder and handles client-side routing correctly. Create a Dockerfile: FROM nginx:latest COPY .next/static /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf This Dockerfile copies the .next/static folder to the appropriate location inside the Nginx image and replaces the default Nginx configuration with the one we created. Build and run the Docker container: docker build -t my-ssg-app . docker run -p 80:80 my-ssg-app This will build the Docker image and run a container that serves the statically generated Next.js app on http://localhost .","title":"SSG"},{"location":"rendering/SSR.html","text":"Server-Side Rendering (SSR) with Next.js For the SSR example, we'll use Next.js, which provides both server-side rendering and static file serving. Build the Next.js app for production: npm run build This will generate an optimized production build in the .next folder. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } } This Nginx configuration proxies all requests to the Next.js server running on http://localhost:3000 . Create a Dockerfile: FROM node:14-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build ENV NODE_ENV production CMD [\"npm\", \"start\"] FROM nginx:latest COPY --from=0 /app/.next /app/.next COPY --from=0 /app/nginx.conf /etc/nginx/conf.d/default.conf This multi-stage Dockerfile first builds the Next.js app using the Node.js base image, and then copies the built .next folder and the Nginx configuration to the Nginx image. Build and run the Docker container: docker build -t my-ssr-app . docker run -p 80:80 my-ssr-app This will build the Docker image and run a container that serves the SSR app on http://localhost . Nginx will proxy requests to the Next.js server, which will render pages on the server and serve them to the client. Note that in the SSR example, we're running both Nginx and the Next.js server inside the same Docker container. In a production environment, you might want to separate them into different containers for better scalability and resource management. These examples should give you a good starting point for setting up production-ready CSR and SSR applications using Docker and Nginx. You can further customize the configurations based on your specific requirements, such as adding HTTPS support, configuring caching, or setting up a reverse proxy. Sure, here's an example of how you can set up a production-ready environment for Static Site Generation (SSG) and Incremental Static Regeneration (ISR) using Next.js and Nginx.","title":"SSR"},{"location":"rendering/concept.html","text":"Web Rendering Strategies Contents Client-Side Rendering (CSR) Server-Side Rendering (SSR) Static Site Generation (SSG) Incremental Static Regeneration (ISR) Client-Side Rendering (CSR) In CSR, the server sends a bare-bones HTML document to the client. The client's browser then downloads the JavaScript and executes it to render the page content. This approach can lead to faster subsequent page loads, but the initial load might be slower. Server-Side Rendering (SSR) With SSR, the server generates the full HTML for a page in response to a request. This means the browser can start rendering the HTML as soon as it's received. SSR can result in a faster initial page load than CSR, but it puts more load on the server. Static Site Generation (SSG) In SSG, HTML pages are generated at build time. This means the server can serve static HTML files, which can be cached and served very quickly. SSG is a good choice for sites where content doesn't change frequently. Incremental Static Regeneration (ISR) ISR is a feature of Next.js that allows you to use static generation on a per-page basis, and regenerate pages by re-fetching data in the background as traffic comes in. This means your users get the benefits of static (always fast, always online), with the benefits of server rendering (always up-to-date). References Understanding CSR, SSR, SSG, and ISR: A Next.js Perspective https://www.youtube.com/watch?v=YkxrbxoqHDw","title":"concept"},{"location":"rendering/concept.html#web-rendering-strategies","text":"","title":"Web Rendering Strategies"},{"location":"rendering/concept.html#contents","text":"Client-Side Rendering (CSR) Server-Side Rendering (SSR) Static Site Generation (SSG) Incremental Static Regeneration (ISR)","title":"Contents"},{"location":"rendering/concept.html#client-side-rendering-csr","text":"In CSR, the server sends a bare-bones HTML document to the client. The client's browser then downloads the JavaScript and executes it to render the page content. This approach can lead to faster subsequent page loads, but the initial load might be slower.","title":"Client-Side Rendering (CSR)"},{"location":"rendering/concept.html#server-side-rendering-ssr","text":"With SSR, the server generates the full HTML for a page in response to a request. This means the browser can start rendering the HTML as soon as it's received. SSR can result in a faster initial page load than CSR, but it puts more load on the server.","title":"Server-Side Rendering (SSR)"},{"location":"rendering/concept.html#static-site-generation-ssg","text":"In SSG, HTML pages are generated at build time. This means the server can serve static HTML files, which can be cached and served very quickly. SSG is a good choice for sites where content doesn't change frequently.","title":"Static Site Generation (SSG)"},{"location":"rendering/concept.html#incremental-static-regeneration-isr","text":"ISR is a feature of Next.js that allows you to use static generation on a per-page basis, and regenerate pages by re-fetching data in the background as traffic comes in. This means your users get the benefits of static (always fast, always online), with the benefits of server rendering (always up-to-date).","title":"Incremental Static Regeneration (ISR)"},{"location":"rendering/concept.html#references","text":"Understanding CSR, SSR, SSG, and ISR: A Next.js Perspective https://www.youtube.com/watch?v=YkxrbxoqHDw","title":"References"},{"location":"terraform/terraform.html","text":"terraform","title":"terraform"},{"location":"terraform/terraform.html#terraform","text":"","title":"terraform"}]}