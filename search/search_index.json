{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"About Me Introduction Hello there! My name is Aditya, and I am a passionate DevOps enthusiast. I have dedicated my career to mastering the art of automating software delivery processes, ensuring seamless collaboration between development and operations teams. Background I have been working in the field of DevOps for some years, during which I have gained extensive experience in various aspects of the discipline. My expertise spans across multiple domains, including continuous integration and continuous deployment (CI/CD), infrastructure as code (IaC), containerization, and cloud computing. Skills Automation Tools: Proficient in utilizing tools like Ansible, Terraform, and Puppet for infrastructure provisioning and configuration management. Containerization: Experienced in working with Docker and Kubernetes for containerizing applications and managing container orchestration. CI/CD Pipelines: Skilled in setting up and maintaining CI/CD pipelines using tools like Jenkins, GitLab CI/CD, and GitHub Actions. Monitoring and Logging: Adept at implementing monitoring and logging solutions such as Prometheus, Grafana, and ELK Stack (Elasticsearch, Logstash, Kibana). Cloud Platforms: Familiar with cloud providers like AWS, Azure, and GCP, and their respective services for deploying and managing applications. Passion and Motivation I firmly believe that DevOps is more than just a set of tools and practices; it's a cultural shift that emphasizes collaboration, automation, and continuous improvement. My passion lies in bridging the gap between development and operations teams, fostering a harmonious and efficient software delivery process. Through this project, I aim to showcase my DevOps skills and demonstrate my ability to tackle real-world challenges. I am excited to embark on this journey and contribute to the ever-evolving world of DevOps.","title":"About Us"},{"location":"index.html#about-me","text":"","title":"About Me"},{"location":"index.html#introduction","text":"Hello there! My name is Aditya, and I am a passionate DevOps enthusiast. I have dedicated my career to mastering the art of automating software delivery processes, ensuring seamless collaboration between development and operations teams.","title":"Introduction"},{"location":"index.html#background","text":"I have been working in the field of DevOps for some years, during which I have gained extensive experience in various aspects of the discipline. My expertise spans across multiple domains, including continuous integration and continuous deployment (CI/CD), infrastructure as code (IaC), containerization, and cloud computing.","title":"Background"},{"location":"index.html#skills","text":"Automation Tools: Proficient in utilizing tools like Ansible, Terraform, and Puppet for infrastructure provisioning and configuration management. Containerization: Experienced in working with Docker and Kubernetes for containerizing applications and managing container orchestration. CI/CD Pipelines: Skilled in setting up and maintaining CI/CD pipelines using tools like Jenkins, GitLab CI/CD, and GitHub Actions. Monitoring and Logging: Adept at implementing monitoring and logging solutions such as Prometheus, Grafana, and ELK Stack (Elasticsearch, Logstash, Kibana). Cloud Platforms: Familiar with cloud providers like AWS, Azure, and GCP, and their respective services for deploying and managing applications.","title":"Skills"},{"location":"index.html#passion-and-motivation","text":"I firmly believe that DevOps is more than just a set of tools and practices; it's a cultural shift that emphasizes collaboration, automation, and continuous improvement. My passion lies in bridging the gap between development and operations teams, fostering a harmonious and efficient software delivery process. Through this project, I aim to showcase my DevOps skills and demonstrate my ability to tackle real-world challenges. I am excited to embark on this journey and contribute to the ever-evolving world of DevOps.","title":"Passion and Motivation"},{"location":"rendering/CSR.html","text":"Client-Side Rendering (CSR) with Create React App For the CSR example, we'll use Create React App, which provides a production build process that generates optimized static files. Build the React app for production: First, let's create a new React app using create-react-app: npx create-react-app my-csr-app cd my-csr-app npm run build This will generate a build folder containing the optimized static files. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; root /usr/share/nginx/html; index index.html; location / { try_files $uri $uri/ /index.html; } } } This Nginx configuration serves the static files from the build folder and handles client-side routing correctly. Create a Dockerfile: FROM nginx:latest COPY build /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf This Dockerfile copies the build folder to the appropriate location inside the Nginx image and replaces the default Nginx configuration with the one we created. Build and run the Docker container: docker build -t my-csr-app . docker run -p 80:80 my-csr-app version: '3' services: app: build: . ports: - '3000:3000' volumes: - ./:/app - /app/node_modules This will build the Docker image and run a container that serves the CSR app on http://localhost .","title":"CSR"},{"location":"rendering/ISR.html","text":"Incremental Static Regeneration (ISR) For ISR, we'll use a combination of Nginx and a Next.js server to handle the static serving and incremental regeneration. Build the Next.js app for production: npm run build This will generate an optimized production build in the .next folder. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } } This Nginx configuration proxies all requests to the Next.js server running on http://localhost:3000 . Create a Dockerfile: FROM node:14-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build ENV NODE_ENV production CMD [\"npm\", \"start\"] FROM nginx:latest COPY --from=0 /app/.next /app/.next COPY --from=0 /app/nginx.conf /etc/nginx/conf.d/default.conf This multi-stage Dockerfile first builds the Next.js app using the Node.js base image, and then copies the built .next folder and the Nginx configuration to the Nginx image. Build and run the Docker container: docker build -t my-isr-app . docker run -p 80:80 my-isr-app This will build the Docker image and run a container that serves the Next.js app with ISR on http://localhost . Nginx will proxy requests to the Next.js server, which will serve the static pages and incrementally regenerate the dynamic pages as needed. In the ISR setup, the Next.js server is responsible for handling the incremental regeneration of pages, while Nginx serves as a reverse proxy and caches the static pages for better performance. Note that for both SSG and ISR, you'll need to configure the appropriate settings in your Next.js app to specify which pages should be statically generated and which pages should use ISR. You can refer to the Next.js documentation for more information on these settings. Additionally, in a production environment, you might want to separate the Nginx and Next.js server into different containers for better scalability and resource management, and possibly add a load balancer or reverse proxy in front of the containers for better load handling and failover. These examples should give you a good starting point for setting up production-ready Static Site Generation (SSG) and Incremental Static Regeneration (ISR) applications using Next.js, Docker, and Nginx. You can further customize the configurations based on your specific requirements, such as adding HTTPS support, configuring caching, or setting up a reverse proxy.","title":"ISR"},{"location":"rendering/SSG.html","text":"Static Site Generation (SSG) Build the Next.js app for production: npm run build This will generate a static version of your Next.js app in the .next/static folder. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; root /usr/share/nginx/html; index index.html; location / { try_files $uri $uri/ /index.html; } } } This Nginx configuration serves the static files from the .next/static folder and handles client-side routing correctly. Create a Dockerfile: FROM nginx:latest COPY .next/static /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf This Dockerfile copies the .next/static folder to the appropriate location inside the Nginx image and replaces the default Nginx configuration with the one we created. Build and run the Docker container: docker build -t my-ssg-app . docker run -p 80:80 my-ssg-app This will build the Docker image and run a container that serves the statically generated Next.js app on http://localhost .","title":"SSG"},{"location":"rendering/SSR.html","text":"Server-Side Rendering (SSR) with Next.js For the SSR example, we'll use Next.js, which provides both server-side rendering and static file serving. Build the Next.js app for production: npm run build This will generate an optimized production build in the .next folder. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } } This Nginx configuration proxies all requests to the Next.js server running on http://localhost:3000 . Create a Dockerfile: FROM node:14-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build ENV NODE_ENV production CMD [\"npm\", \"start\"] FROM nginx:latest COPY --from=0 /app/.next /app/.next COPY --from=0 /app/nginx.conf /etc/nginx/conf.d/default.conf This multi-stage Dockerfile first builds the Next.js app using the Node.js base image, and then copies the built .next folder and the Nginx configuration to the Nginx image. Build and run the Docker container: docker build -t my-ssr-app . docker run -p 80:80 my-ssr-app This will build the Docker image and run a container that serves the SSR app on http://localhost . Nginx will proxy requests to the Next.js server, which will render pages on the server and serve them to the client. Note that in the SSR example, we're running both Nginx and the Next.js server inside the same Docker container. In a production environment, you might want to separate them into different containers for better scalability and resource management. These examples should give you a good starting point for setting up production-ready CSR and SSR applications using Docker and Nginx. You can further customize the configurations based on your specific requirements, such as adding HTTPS support, configuring caching, or setting up a reverse proxy. Sure, here's an example of how you can set up a production-ready environment for Static Site Generation (SSG) and Incremental Static Regeneration (ISR) using Next.js and Nginx.","title":"SSR"},{"location":"rendering/concept.html","text":"Web Rendering Strategies Contents Client-Side Rendering (CSR) Server-Side Rendering (SSR) Static Site Generation (SSG) Incremental Static Regeneration (ISR) Client-Side Rendering (CSR) In CSR, the server sends a bare-bones HTML document to the client. The client's browser then downloads the JavaScript and executes it to render the page content. This approach can lead to faster subsequent page loads, but the initial load might be slower. Server-Side Rendering (SSR) With SSR, the server generates the full HTML for a page in response to a request. This means the browser can start rendering the HTML as soon as it's received. SSR can result in a faster initial page load than CSR, but it puts more load on the server. Static Site Generation (SSG) In SSG, HTML pages are generated at build time. This means the server can serve static HTML files, which can be cached and served very quickly. SSG is a good choice for sites where content doesn't change frequently. Incremental Static Regeneration (ISR) ISR is a feature of Next.js that allows you to use static generation on a per-page basis, and regenerate pages by re-fetching data in the background as traffic comes in. This means your users get the benefits of static (always fast, always online), with the benefits of server rendering (always up-to-date). References Understanding CSR, SSR, SSG, and ISR: A Next.js Perspective https://www.youtube.com/watch?v=YkxrbxoqHDw","title":"concept"},{"location":"rendering/concept.html#web-rendering-strategies","text":"","title":"Web Rendering Strategies"},{"location":"rendering/concept.html#contents","text":"Client-Side Rendering (CSR) Server-Side Rendering (SSR) Static Site Generation (SSG) Incremental Static Regeneration (ISR)","title":"Contents"},{"location":"rendering/concept.html#client-side-rendering-csr","text":"In CSR, the server sends a bare-bones HTML document to the client. The client's browser then downloads the JavaScript and executes it to render the page content. This approach can lead to faster subsequent page loads, but the initial load might be slower.","title":"Client-Side Rendering (CSR)"},{"location":"rendering/concept.html#server-side-rendering-ssr","text":"With SSR, the server generates the full HTML for a page in response to a request. This means the browser can start rendering the HTML as soon as it's received. SSR can result in a faster initial page load than CSR, but it puts more load on the server.","title":"Server-Side Rendering (SSR)"},{"location":"rendering/concept.html#static-site-generation-ssg","text":"In SSG, HTML pages are generated at build time. This means the server can serve static HTML files, which can be cached and served very quickly. SSG is a good choice for sites where content doesn't change frequently.","title":"Static Site Generation (SSG)"},{"location":"rendering/concept.html#incremental-static-regeneration-isr","text":"ISR is a feature of Next.js that allows you to use static generation on a per-page basis, and regenerate pages by re-fetching data in the background as traffic comes in. This means your users get the benefits of static (always fast, always online), with the benefits of server rendering (always up-to-date).","title":"Incremental Static Regeneration (ISR)"},{"location":"rendering/concept.html#references","text":"Understanding CSR, SSR, SSG, and ISR: A Next.js Perspective https://www.youtube.com/watch?v=YkxrbxoqHDw","title":"References"}]}