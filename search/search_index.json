{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"About Me Introduction Hello there! My name is Aditya, and I am a passionate DevOps enthusiast. I have dedicated my career to mastering the art of automating software delivery processes, ensuring seamless collaboration between development and operations teams. Background I have been working in the field of DevOps for some years, during which I have gained extensive experience in various aspects of the discipline. My expertise spans across multiple domains, including continuous integration and continuous deployment (CI/CD), infrastructure as code (IaC), containerization, and cloud computing. Skills Automation Tools: Proficient in utilizing tools like Ansible, Terraform, and Puppet for infrastructure provisioning and configuration management. Containerization: Experienced in working with Docker and Kubernetes for containerizing applications and managing container orchestration. CI/CD Pipelines: Skilled in setting up and maintaining CI/CD pipelines using tools like Jenkins, GitLab CI/CD, and GitHub Actions. Monitoring and Logging: Adept at implementing monitoring and logging solutions such as Prometheus, Grafana, and ELK Stack (Elasticsearch, Logstash, Kibana). Cloud Platforms: Familiar with cloud providers like AWS, Azure, and GCP, and their respective services for deploying and managing applications. Passion and Motivation I firmly believe that DevOps is more than just a set of tools and practices; it's a cultural shift that emphasizes collaboration, automation, and continuous improvement. My passion lies in bridging the gap between development and operations teams, fostering a harmonious and efficient software delivery process. Through this project, I aim to showcase my DevOps skills and demonstrate my ability to tackle real-world challenges. I am excited to embark on this journey and contribute to the ever-evolving world of DevOps.","title":"About Us"},{"location":"index.html#about-me","text":"","title":"About Me"},{"location":"index.html#introduction","text":"Hello there! My name is Aditya, and I am a passionate DevOps enthusiast. I have dedicated my career to mastering the art of automating software delivery processes, ensuring seamless collaboration between development and operations teams.","title":"Introduction"},{"location":"index.html#background","text":"I have been working in the field of DevOps for some years, during which I have gained extensive experience in various aspects of the discipline. My expertise spans across multiple domains, including continuous integration and continuous deployment (CI/CD), infrastructure as code (IaC), containerization, and cloud computing.","title":"Background"},{"location":"index.html#skills","text":"Automation Tools: Proficient in utilizing tools like Ansible, Terraform, and Puppet for infrastructure provisioning and configuration management. Containerization: Experienced in working with Docker and Kubernetes for containerizing applications and managing container orchestration. CI/CD Pipelines: Skilled in setting up and maintaining CI/CD pipelines using tools like Jenkins, GitLab CI/CD, and GitHub Actions. Monitoring and Logging: Adept at implementing monitoring and logging solutions such as Prometheus, Grafana, and ELK Stack (Elasticsearch, Logstash, Kibana). Cloud Platforms: Familiar with cloud providers like AWS, Azure, and GCP, and their respective services for deploying and managing applications.","title":"Skills"},{"location":"index.html#passion-and-motivation","text":"I firmly believe that DevOps is more than just a set of tools and practices; it's a cultural shift that emphasizes collaboration, automation, and continuous improvement. My passion lies in bridging the gap between development and operations teams, fostering a harmonious and efficient software delivery process. Through this project, I aim to showcase my DevOps skills and demonstrate my ability to tackle real-world challenges. I am excited to embark on this journey and contribute to the ever-evolving world of DevOps.","title":"Passion and Motivation"},{"location":"bash/conditional-expression.html","text":"In Bash, -z , -f , and -d are conditional expressions used in if statements and test commands to evaluate certain conditions. Here's a brief explanation of each: -z : Tests if a string is empty (has zero length). Example: if [ -z \"$variable\" ]; then echo \"Variable is empty\"; fi -f : Tests if a file exists and is a regular file. Example: if [ -f \"file.txt\" ]; then echo \"file.txt exists\"; fi -d : Tests if a directory exists. Example: if [ -d \"directory\" ]; then echo \"directory exists\"; fi These are just a few examples of the many conditional expressions available in Bash. Here's a list of some commonly used conditional expressions: -e : Tests if a file exists (regardless of its type). -s : Tests if a file exists and has a size greater than zero. -r , -w , -x : Tests if a file has read, write, or execute permissions, respectively. -eq , -ne , -lt , -le , -gt , -ge : Arithmetic comparisons for integers. = , != , < , > : String comparisons. && , || : Logical AND and OR operators. For the official documentation and a complete list of conditional expressions, you can refer to the following links: Bash Manual - Conditional Constructs: https://www.gnu.org/software/bash/manual/html_node/Conditional-Constructs.html Bash Reference Manual - Bash Conditional Expressions: https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html These resources provide detailed information about the various conditional expressions, their usage, and additional examples.","title":"Conditional expression"},{"location":"bash/special-variable.html","text":"In shell scripting, there are several special variables (also known as shell parameters) that have specific meanings and behaviors. These special variables are often used in scripts to handle arguments, statuses, and other context-specific information. Here is a list of some commonly used special variables: Special Shell Variables $# Represents the number of positional parameters (arguments) passed to the script or function. Example: If a script is called with three arguments ( ./script.sh arg1 arg2 arg3 ), $# will be 3 . $0 Contains the name of the script or the command being executed. Example: If a script is called as ./script.sh , $0 will be ./script.sh . $1, $2, ... $N Represent the positional parameters (arguments) passed to the script or function. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $1 will be arg1 and $2 will be arg2 . $* Represents all the positional parameters as a single word. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $* will be arg1 arg2 . $@ Represents all the positional parameters as separate words. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $@ will be arg1 arg2 . $? Contains the exit status of the last command executed. Example: After a command ls is executed, $? will contain the exit status of ls . $$ Contains the process ID (PID) of the shell executing the script. Example: If a script is running, $$ will provide the PID of the shell. $! Contains the process ID of the last background command executed. Example: If a command is run in the background ( sleep 100 & ), $! will contain the PID of the sleep command. $- Contains the current options set for the shell. Example: If the shell has options like -x (for debugging), $- will include x . $_ Contains the last argument of the previous command. Example: If a command echo foo is executed, $_ will contain foo . Usage Examples Here's a small script to demonstrate some of these variables: #!/bin/bash echo \"Script name: $0\" echo \"Number of arguments: $#\" echo \"All arguments as a single word: $*\" echo \"All arguments as separate words: $@\" echo \"First argument: $1\" echo \"Second argument: $2\" echo \"Exit status of the last command: $?\" echo \"Process ID of the shell: $$\" echo \"Process ID of the last background command: $!\" # Run a background command sleep 10 & echo \"Process ID of the sleep command: $!\" echo \"Last argument of the previous command: $_\" If you run this script with some arguments, for example: ./script.sh arg1 arg2 You would see output corresponding to the special variables based on the provided arguments and the script\u2019s execution context.","title":"Special variable"},{"location":"bash/special-variable.html#special-shell-variables","text":"$# Represents the number of positional parameters (arguments) passed to the script or function. Example: If a script is called with three arguments ( ./script.sh arg1 arg2 arg3 ), $# will be 3 . $0 Contains the name of the script or the command being executed. Example: If a script is called as ./script.sh , $0 will be ./script.sh . $1, $2, ... $N Represent the positional parameters (arguments) passed to the script or function. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $1 will be arg1 and $2 will be arg2 . $* Represents all the positional parameters as a single word. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $* will be arg1 arg2 . $@ Represents all the positional parameters as separate words. Example: If a script is called with arguments ( ./script.sh arg1 arg2 ), $@ will be arg1 arg2 . $? Contains the exit status of the last command executed. Example: After a command ls is executed, $? will contain the exit status of ls . $$ Contains the process ID (PID) of the shell executing the script. Example: If a script is running, $$ will provide the PID of the shell. $! Contains the process ID of the last background command executed. Example: If a command is run in the background ( sleep 100 & ), $! will contain the PID of the sleep command. $- Contains the current options set for the shell. Example: If the shell has options like -x (for debugging), $- will include x . $_ Contains the last argument of the previous command. Example: If a command echo foo is executed, $_ will contain foo .","title":"Special Shell Variables"},{"location":"bash/special-variable.html#usage-examples","text":"Here's a small script to demonstrate some of these variables: #!/bin/bash echo \"Script name: $0\" echo \"Number of arguments: $#\" echo \"All arguments as a single word: $*\" echo \"All arguments as separate words: $@\" echo \"First argument: $1\" echo \"Second argument: $2\" echo \"Exit status of the last command: $?\" echo \"Process ID of the shell: $$\" echo \"Process ID of the last background command: $!\" # Run a background command sleep 10 & echo \"Process ID of the sleep command: $!\" echo \"Last argument of the previous command: $_\" If you run this script with some arguments, for example: ./script.sh arg1 arg2 You would see output corresponding to the special variables based on the provided arguments and the script\u2019s execution context.","title":"Usage Examples"},{"location":"docker/docker.html","text":"docker","title":"Dockercompose"},{"location":"docker/docker.html#docker","text":"","title":"docker"},{"location":"golang/lesson-1.html","text":"Variable address passing In this example, we have two variables, name and age, that we want to read from the terminal. Here's how it works: We use the fmt.Print() function to prompt the user to enter their name. We then use fmt.Scan(&name) to read the user's input and store it in the name variable. The & symbol is used to pass the address of the variable to the Scan() function. We check for any errors that may have occurred during the input reading process using the returned error value. We repeat the same process for the age variable, using fmt.Scan(&age) to read the user's input. Finally, we use fmt.Printf() to print the user's name and age. Alternatively, you can use the fmt.Scanln() function, which reads input until a newline character is encountered: fmt.Print(\"Enter your name and age: \") _, err := fmt.Scanln(&name, &age) if err != nil { fmt.Println(\"Error:\", err) return } In this case, the user can enter their name and age on the same line, separated by a space, and the input will be read correctly. Remember that the Scan() and Scanln() functions return the number of successfully scanned items and an error value, so it's important to check for any errors that may have occurred during the input reading process. Certainly! Let's break down the fmt.Scan() function: fmt.Scan(a ...any) (n int, err error) This is the function signature of fmt.Scan() . a ...any is a variadic parameter, which means it can accept any number of arguments of any type. The function returns two values: n int : The number of successfully scanned items. err error : An error value, if any, that occurred during the scanning process. fmt.Scan(&name, &age) In this example, we're passing two variables, name and age , to the Scan() function. The & symbol is used to pass the address of the variables, so that the Scan() function can modify their values directly. The Scan() function will read the user's input and store the values in the name and age variables. _, err := fmt.Scan(&name, &age) Here, we're using the short variable declaration syntax ( := ) to declare two variables: _ and err . The _ is an unnamed variable, which is used to discard the first return value (the number of successfully scanned items). The err variable is used to store the error value returned by the Scan() function. if err != nil { ... } After calling fmt.Scan() , we check if an error occurred during the scanning process. If err is not nil , it means an error occurred, and we can handle it accordingly (e.g., print an error message, return from the function, etc.). In summary, the fmt.Scan() function is used to read user input from the terminal and store the values in the provided variables. It returns the number of successfully scanned items and an error value, which you should always check to ensure that the input was read correctly.","title":"Lesson 1"},{"location":"golang/lesson-1.html#variable-address-passing","text":"In this example, we have two variables, name and age, that we want to read from the terminal. Here's how it works: We use the fmt.Print() function to prompt the user to enter their name. We then use fmt.Scan(&name) to read the user's input and store it in the name variable. The & symbol is used to pass the address of the variable to the Scan() function. We check for any errors that may have occurred during the input reading process using the returned error value. We repeat the same process for the age variable, using fmt.Scan(&age) to read the user's input. Finally, we use fmt.Printf() to print the user's name and age. Alternatively, you can use the fmt.Scanln() function, which reads input until a newline character is encountered: fmt.Print(\"Enter your name and age: \") _, err := fmt.Scanln(&name, &age) if err != nil { fmt.Println(\"Error:\", err) return } In this case, the user can enter their name and age on the same line, separated by a space, and the input will be read correctly. Remember that the Scan() and Scanln() functions return the number of successfully scanned items and an error value, so it's important to check for any errors that may have occurred during the input reading process.","title":"Variable address passing"},{"location":"golang/lesson-1.html#certainly-lets-break-down-the-fmtscan-function","text":"fmt.Scan(a ...any) (n int, err error) This is the function signature of fmt.Scan() . a ...any is a variadic parameter, which means it can accept any number of arguments of any type. The function returns two values: n int : The number of successfully scanned items. err error : An error value, if any, that occurred during the scanning process. fmt.Scan(&name, &age) In this example, we're passing two variables, name and age , to the Scan() function. The & symbol is used to pass the address of the variables, so that the Scan() function can modify their values directly. The Scan() function will read the user's input and store the values in the name and age variables. _, err := fmt.Scan(&name, &age) Here, we're using the short variable declaration syntax ( := ) to declare two variables: _ and err . The _ is an unnamed variable, which is used to discard the first return value (the number of successfully scanned items). The err variable is used to store the error value returned by the Scan() function. if err != nil { ... } After calling fmt.Scan() , we check if an error occurred during the scanning process. If err is not nil , it means an error occurred, and we can handle it accordingly (e.g., print an error message, return from the function, etc.). In summary, the fmt.Scan() function is used to read user input from the terminal and store the values in the provided variables. It returns the number of successfully scanned items and an error value, which you should always check to ensure that the input was read correctly.","title":"Certainly! Let's break down the fmt.Scan() function:"},{"location":"golang/pointers-dereferencing.html","text":"Sure! Pointers and dereferencing are fundamental concepts in programming, especially in languages like Go, C, and C++. Let's go through a detailed explanation with examples. What is a Pointer? A pointer is a variable that holds the memory address of another variable. Instead of storing a data value directly, a pointer stores the address where the value is located. Declaration of a Pointer In Go, you declare a pointer by using the * operator. Here's a basic example: package main import ( \"fmt\" ) func main() { var x int = 10 var p *int p = &x fmt.Println(\"Value of x:\", x) fmt.Println(\"Address of x:\", &x) fmt.Println(\"Value of p (address of x):\", p) fmt.Println(\"Value at the address stored in p:\", *p) } Explanation: var x int = 10 : Declare an integer variable x with a value of 10. var p *int : Declare a pointer variable p that can hold the address of an integer. p = &x : The & operator is used to get the address of the variable x . This address is assigned to p . fmt.Println(\"Value of x:\", x) : Prints the value of x , which is 10. fmt.Println(\"Address of x:\", &x) : Prints the memory address of x . fmt.Println(\"Value of p (address of x):\", p) : Prints the value of p , which is the address of x . fmt.Println(\"Value at the address stored in p:\", *p) : The * operator is used to dereference the pointer p . It gives the value stored at the address held by p , which is 10. Pointers with Functions Using pointers with functions allows you to modify the original value of a variable from within the function. Here's an example to illustrate this: package main import ( \"fmt\" ) func main() { var x int = 10 fmt.Println(\"Before change:\", x) changeValue(&x) fmt.Println(\"After change:\", x) } func changeValue(p *int) { *p = 20 } Explanation: changeValue(&x) : Passes the address of x to the changeValue function. func changeValue(p *int) : The function takes a pointer to an integer as a parameter. *p = 20 : Dereferences the pointer p and changes the value at the address p points to. This effectively changes the value of x to 20. Practical Example: Swapping Values A practical example of using pointers is to swap the values of two variables: package main import ( \"fmt\" ) func main() { a := 5 b := 10 fmt.Println(\"Before swap: a =\", a, \"b =\", b) swap(&a, &b) fmt.Println(\"After swap: a =\", a, \"b =\", b) } func swap(x, y *int) { temp := *x *x = *y *y = temp } Explanation: swap(&a, &b) : Passes the addresses of a and b to the swap function. func swap(x, y *int) : The function takes two pointers to integers as parameters. temp := *x : Dereferences x to get the value of a and stores it in temp . *x = *y : Dereferences y to get the value of b and assigns it to a . *y = temp : Assigns the value of temp (original value of a ) to b . Summary: Pointer ( *int ) : A variable that holds the memory address of an integer. Address-of ( &x ) : Operator to get the address of variable x . Dereference ( *p ) : Operator to access the value stored at the address in pointer p . Using pointers allows for more efficient memory usage and the ability to modify variables directly within functions, making your programs more powerful and flexible.","title":"Pointers dereferencing"},{"location":"golang/pointers-dereferencing.html#what-is-a-pointer","text":"A pointer is a variable that holds the memory address of another variable. Instead of storing a data value directly, a pointer stores the address where the value is located.","title":"What is a Pointer?"},{"location":"golang/pointers-dereferencing.html#declaration-of-a-pointer","text":"In Go, you declare a pointer by using the * operator. Here's a basic example: package main import ( \"fmt\" ) func main() { var x int = 10 var p *int p = &x fmt.Println(\"Value of x:\", x) fmt.Println(\"Address of x:\", &x) fmt.Println(\"Value of p (address of x):\", p) fmt.Println(\"Value at the address stored in p:\", *p) }","title":"Declaration of a Pointer"},{"location":"golang/pointers-dereferencing.html#explanation","text":"var x int = 10 : Declare an integer variable x with a value of 10. var p *int : Declare a pointer variable p that can hold the address of an integer. p = &x : The & operator is used to get the address of the variable x . This address is assigned to p . fmt.Println(\"Value of x:\", x) : Prints the value of x , which is 10. fmt.Println(\"Address of x:\", &x) : Prints the memory address of x . fmt.Println(\"Value of p (address of x):\", p) : Prints the value of p , which is the address of x . fmt.Println(\"Value at the address stored in p:\", *p) : The * operator is used to dereference the pointer p . It gives the value stored at the address held by p , which is 10.","title":"Explanation:"},{"location":"golang/pointers-dereferencing.html#pointers-with-functions","text":"Using pointers with functions allows you to modify the original value of a variable from within the function. Here's an example to illustrate this: package main import ( \"fmt\" ) func main() { var x int = 10 fmt.Println(\"Before change:\", x) changeValue(&x) fmt.Println(\"After change:\", x) } func changeValue(p *int) { *p = 20 }","title":"Pointers with Functions"},{"location":"golang/pointers-dereferencing.html#explanation_1","text":"changeValue(&x) : Passes the address of x to the changeValue function. func changeValue(p *int) : The function takes a pointer to an integer as a parameter. *p = 20 : Dereferences the pointer p and changes the value at the address p points to. This effectively changes the value of x to 20.","title":"Explanation:"},{"location":"golang/pointers-dereferencing.html#practical-example-swapping-values","text":"A practical example of using pointers is to swap the values of two variables: package main import ( \"fmt\" ) func main() { a := 5 b := 10 fmt.Println(\"Before swap: a =\", a, \"b =\", b) swap(&a, &b) fmt.Println(\"After swap: a =\", a, \"b =\", b) } func swap(x, y *int) { temp := *x *x = *y *y = temp }","title":"Practical Example: Swapping Values"},{"location":"golang/pointers-dereferencing.html#explanation_2","text":"swap(&a, &b) : Passes the addresses of a and b to the swap function. func swap(x, y *int) : The function takes two pointers to integers as parameters. temp := *x : Dereferences x to get the value of a and stores it in temp . *x = *y : Dereferences y to get the value of b and assigns it to a . *y = temp : Assigns the value of temp (original value of a ) to b .","title":"Explanation:"},{"location":"golang/pointers-dereferencing.html#summary","text":"Pointer ( *int ) : A variable that holds the memory address of an integer. Address-of ( &x ) : Operator to get the address of variable x . Dereference ( *p ) : Operator to access the value stored at the address in pointer p . Using pointers allows for more efficient memory usage and the ability to modify variables directly within functions, making your programs more powerful and flexible.","title":"Summary:"},{"location":"kubernetes/kubernetes.html","text":"kubernetes","title":"kubernetes"},{"location":"kubernetes/kubernetes.html#kubernetes","text":"","title":"kubernetes"},{"location":"logging/logging.html","text":"logging","title":"logging"},{"location":"logging/logging.html#logging","text":"","title":"logging"},{"location":"monitoring/monitoring.html","text":"monitoring","title":"monitoring"},{"location":"monitoring/monitoring.html#monitoring","text":"","title":"monitoring"},{"location":"rendering/CSR.html","text":"Client-Side Rendering (CSR) with Create React App For the CSR example, we'll use Create React App, which provides a production build process that generates optimized static files. Build the React app for production: First, let's create a new React app using create-react-app: npx create-react-app my-csr-app cd my-csr-app npm run build This will generate a build folder containing the optimized static files. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; root /usr/share/nginx/html; index index.html; location / { try_files $uri $uri/ /index.html; } } } This Nginx configuration serves the static files from the build folder and handles client-side routing correctly. Create a Dockerfile: FROM nginx:latest COPY build /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf This Dockerfile copies the build folder to the appropriate location inside the Nginx image and replaces the default Nginx configuration with the one we created. Build and run the Docker container: docker build -t my-csr-app . docker run -p 80:80 my-csr-app version: '3' services: app: build: . ports: - '3000:3000' volumes: - ./:/app - /app/node_modules This will build the Docker image and run a container that serves the CSR app on http://localhost .","title":"CSR"},{"location":"rendering/ISR.html","text":"Incremental Static Regeneration (ISR) For ISR, we'll use a combination of Nginx and a Next.js server to handle the static serving and incremental regeneration. Build the Next.js app for production: npm run build This will generate an optimized production build in the .next folder. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } } This Nginx configuration proxies all requests to the Next.js server running on http://localhost:3000 . Create a Dockerfile: FROM node:14-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build ENV NODE_ENV production CMD [\"npm\", \"start\"] FROM nginx:latest COPY --from=0 /app/.next /app/.next COPY --from=0 /app/nginx.conf /etc/nginx/conf.d/default.conf This multi-stage Dockerfile first builds the Next.js app using the Node.js base image, and then copies the built .next folder and the Nginx configuration to the Nginx image. Build and run the Docker container: docker build -t my-isr-app . docker run -p 80:80 my-isr-app This will build the Docker image and run a container that serves the Next.js app with ISR on http://localhost . Nginx will proxy requests to the Next.js server, which will serve the static pages and incrementally regenerate the dynamic pages as needed. In the ISR setup, the Next.js server is responsible for handling the incremental regeneration of pages, while Nginx serves as a reverse proxy and caches the static pages for better performance. Note that for both SSG and ISR, you'll need to configure the appropriate settings in your Next.js app to specify which pages should be statically generated and which pages should use ISR. You can refer to the Next.js documentation for more information on these settings. Additionally, in a production environment, you might want to separate the Nginx and Next.js server into different containers for better scalability and resource management, and possibly add a load balancer or reverse proxy in front of the containers for better load handling and failover. These examples should give you a good starting point for setting up production-ready Static Site Generation (SSG) and Incremental Static Regeneration (ISR) applications using Next.js, Docker, and Nginx. You can further customize the configurations based on your specific requirements, such as adding HTTPS support, configuring caching, or setting up a reverse proxy.","title":"ISR"},{"location":"rendering/SSG.html","text":"Static Site Generation (SSG) Build the Next.js app for production: npm run build This will generate a static version of your Next.js app in the .next/static folder. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; root /usr/share/nginx/html; index index.html; location / { try_files $uri $uri/ /index.html; } } } This Nginx configuration serves the static files from the .next/static folder and handles client-side routing correctly. Create a Dockerfile: FROM nginx:latest COPY .next/static /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf This Dockerfile copies the .next/static folder to the appropriate location inside the Nginx image and replaces the default Nginx configuration with the one we created. Build and run the Docker container: docker build -t my-ssg-app . docker run -p 80:80 my-ssg-app This will build the Docker image and run a container that serves the statically generated Next.js app on http://localhost .","title":"SSG"},{"location":"rendering/SSR.html","text":"Server-Side Rendering (SSR) with Next.js For the SSR example, we'll use Next.js, which provides both server-side rendering and static file serving. Build the Next.js app for production: npm run build This will generate an optimized production build in the .next folder. Create an Nginx configuration file ( nginx.conf ): events { worker_connections 1024; } http { server { listen 80; server_name example.com; location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } } This Nginx configuration proxies all requests to the Next.js server running on http://localhost:3000 . Create a Dockerfile: FROM node:14-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build ENV NODE_ENV production CMD [\"npm\", \"start\"] FROM nginx:latest COPY --from=0 /app/.next /app/.next COPY --from=0 /app/nginx.conf /etc/nginx/conf.d/default.conf This multi-stage Dockerfile first builds the Next.js app using the Node.js base image, and then copies the built .next folder and the Nginx configuration to the Nginx image. Build and run the Docker container: docker build -t my-ssr-app . docker run -p 80:80 my-ssr-app This will build the Docker image and run a container that serves the SSR app on http://localhost . Nginx will proxy requests to the Next.js server, which will render pages on the server and serve them to the client. Note that in the SSR example, we're running both Nginx and the Next.js server inside the same Docker container. In a production environment, you might want to separate them into different containers for better scalability and resource management. These examples should give you a good starting point for setting up production-ready CSR and SSR applications using Docker and Nginx. You can further customize the configurations based on your specific requirements, such as adding HTTPS support, configuring caching, or setting up a reverse proxy. Sure, here's an example of how you can set up a production-ready environment for Static Site Generation (SSG) and Incremental Static Regeneration (ISR) using Next.js and Nginx.","title":"SSR"},{"location":"rendering/concept.html","text":"Web Rendering Strategies Contents Client-Side Rendering (CSR) Server-Side Rendering (SSR) Static Site Generation (SSG) Incremental Static Regeneration (ISR) Client-Side Rendering (CSR) In CSR, the server sends a bare-bones HTML document to the client. The client's browser then downloads the JavaScript and executes it to render the page content. This approach can lead to faster subsequent page loads, but the initial load might be slower. Server-Side Rendering (SSR) With SSR, the server generates the full HTML for a page in response to a request. This means the browser can start rendering the HTML as soon as it's received. SSR can result in a faster initial page load than CSR, but it puts more load on the server. Static Site Generation (SSG) In SSG, HTML pages are generated at build time. This means the server can serve static HTML files, which can be cached and served very quickly. SSG is a good choice for sites where content doesn't change frequently. Incremental Static Regeneration (ISR) ISR is a feature of Next.js that allows you to use static generation on a per-page basis, and regenerate pages by re-fetching data in the background as traffic comes in. This means your users get the benefits of static (always fast, always online), with the benefits of server rendering (always up-to-date). References Understanding CSR, SSR, SSG, and ISR: A Next.js Perspective https://www.youtube.com/watch?v=YkxrbxoqHDw","title":"concept"},{"location":"rendering/concept.html#web-rendering-strategies","text":"","title":"Web Rendering Strategies"},{"location":"rendering/concept.html#contents","text":"Client-Side Rendering (CSR) Server-Side Rendering (SSR) Static Site Generation (SSG) Incremental Static Regeneration (ISR)","title":"Contents"},{"location":"rendering/concept.html#client-side-rendering-csr","text":"In CSR, the server sends a bare-bones HTML document to the client. The client's browser then downloads the JavaScript and executes it to render the page content. This approach can lead to faster subsequent page loads, but the initial load might be slower.","title":"Client-Side Rendering (CSR)"},{"location":"rendering/concept.html#server-side-rendering-ssr","text":"With SSR, the server generates the full HTML for a page in response to a request. This means the browser can start rendering the HTML as soon as it's received. SSR can result in a faster initial page load than CSR, but it puts more load on the server.","title":"Server-Side Rendering (SSR)"},{"location":"rendering/concept.html#static-site-generation-ssg","text":"In SSG, HTML pages are generated at build time. This means the server can serve static HTML files, which can be cached and served very quickly. SSG is a good choice for sites where content doesn't change frequently.","title":"Static Site Generation (SSG)"},{"location":"rendering/concept.html#incremental-static-regeneration-isr","text":"ISR is a feature of Next.js that allows you to use static generation on a per-page basis, and regenerate pages by re-fetching data in the background as traffic comes in. This means your users get the benefits of static (always fast, always online), with the benefits of server rendering (always up-to-date).","title":"Incremental Static Regeneration (ISR)"},{"location":"rendering/concept.html#references","text":"Understanding CSR, SSR, SSG, and ISR: A Next.js Perspective https://www.youtube.com/watch?v=YkxrbxoqHDw","title":"References"},{"location":"terraform/terraform.html","text":"terraform","title":"terraform"},{"location":"terraform/terraform.html#terraform","text":"","title":"terraform"}]}